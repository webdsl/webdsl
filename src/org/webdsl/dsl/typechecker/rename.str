module org/webdsl/dsl/typechecker/rename

/**
 * Renaming
 * --
 * At the start of the rewriting process, all variables are renamed by annotating them, to make them unique.
 * Declaring is part of the renaming process
 */

imports
  libstrategolib
  org/webdsl/dsl/typechecker/-

imports
  libwebdsl-front

signature constructors

  TopLevelName : Term -> Term

rules

  rename-top = log-time(map-toplevel(rename, rename-toplevel) | "rename")
  rename-toplevel = with-toplevel-name(rename-all)

rules

  rename-wrapper(rename-strategy) =
    normalize-constructors //fragments created in desugaring could be using non-normalized constructors
  ;	with-origin(rename-strategy)

  rename-all = rename-wrapper(alltd(rename))

  rename-closed =
    {| Rename:
       rename-all
     |}

  built-in-template-rule-setup = prevent-strategy-removal;fail
  prevent-strategy-removal = in-def-rename-scope(id)
  in-def-rename-scope(s) =
    {| Rename, InDef, VarInContext
     : rules ( InDef := True() )
     ; s
     |}

  rename = Rename

  /**
   * rename-bound does the actual renaming. The other rules guide the application of rename-bound
   */
  rename-bound(|srt) :
    x -> y
    with if <Rename> Var(x)  // if the name is already known, the variable declaration is shadowing, which is not allowed.
                             // constraints in languages/action/typechecker/variable-shadowing trigger on x without name annotation
            ; ?Var(<not(has-anno(?IsEntityPropertyName()))>) // collision with entity property is allowed, can always refer to property with this.x, and implicit property name collisions such as variable 'name' would be confusing
         <+ where(InTypeCheckingPhase)
            ; <TypeOf> x       // if TypeOf dynamic rule exists for 'x' then the current variable declaration is shadowing a global/request/session var (see data-model/global-variables.str, action/request-var.str, data-model/declare.str)
         then y := x
         else y := x{<toplevel-rename> x}
            ; rename-bound-rules(|x,y,srt)
         end

        /*
  rename-bound(|srt) :
    x{} -> y
    with  y := x{<toplevel-rename> x}
        ; rename-bound-rules(|x,y,srt)
  rename-bound(|srt) :
    x{anno*} -> x{anno*}
    where not([] := anno*)
    with  rename-bound-rules(|x{},x{anno*},srt) // do not rename if already given a unique name
                  */
  /**
   * adds 'ImmutableReference()' annotation to srt, unless it is a Ref type, then invokes rename-bound.
   * can be used e.g. for 'for' loop variables, to indicate that the reference may not directly be assigned to,
   * but editing its entity properties is allowed
   */
  rename-bound-immutable(|srt) :
    x -> <rename-bound(|srt1)> x
    with if not(<is-ref-type> srt)
         then _{anno*} := srt
            ; srt1 := srt{ImmutableReference(),anno*}
         else srt1 := srt end

  has-immutable-anno = has-anno(ImmutableReference())
  strip-immutable-anno = remove-anno(ImmutableReference())
  add-immutable-anno = add-anno(|ImmutableReference())
  signature constructors ImmutableReference : Term

rules

  rename-bound-rules(|x,y,srt) =
    if <?RefSort(refsrt{anno*})> srt
    then normsrt := refsrt{IsRefSort(),anno*}
    else normsrt := srt
    end
  ; rules (
      Rename : Var(x) -> Var(y) where rules( VarIsUsed : y )
      RenameType : GenericSort("EntityTypeNamed",[x]) -> GenericSort("EntityTypeNamed",[y])
      RenameType : SimpleSort(x) -> GenericSort("EntityTypeNamed",[y])
      Rename : Qualified(x, z) -> Qualified(y, z)
      TypeOf : y -> normsrt
    )
  ; if FunctionSort(_, _) := normsrt then
    rules(
        Rename : ThisCallFunctionExpName(x) -> y // for function-exp
      )
    end
  //; try(rename-bound-hook(|x,y))

  rename-type = ?s; (RenameType <+ !s)

signature constructors ThisCallFunctionExpName: Term -> Term

rules

  /**
   * Use this rule to get a stack trace upon failure in rename, in the rhs of a rewrite rule.
   * Since 'with' is like 'where', in the sense that it restores the old term,
   * <with(rename-all)> in front of the rhs will prevent the actual renaming.
   * Usage:
   *   desugar: a -> <with-rename-all> b
   */
  with-rename-all :
    a -> b
    with b := <rename-all> a

rules

  /**
   *  The difference with VarInContext rule and Rename is that
   *  VarInContext is only defined when a whole definition is renamed.
   *  This makes it suitable for doing a bigbagof-VarInContext to determine closures.
   *  The Rename dynamic rule does not contain the complete closure at all times,
   *  e.g. when rename-all is called on only a part of a definition.
   *  TODO rename this dynamic rule
   */
  declare-vars-in-entity-context =
    try(
      ?name
    ; rules( VarInContext :+= Var(name))
    )

  declare-vars-in-context =
    try(
      ?name
    ; where(context := <InDef>) //important, this makes sure that vars are only added when a complete definition is visible, otherwise the closure would be incomplete
    ; rules( VarInContext :+= Var(name))
    )

//  empty-args-in-context =
//    repeat(once-VarInContext)

  declare-args-in-context =
    map(\Arg(name,_) -> name with rules( VarInContext :+= Var(name) )\)

rules

  // prefix with given prefix, if prefix not already present
  prefix-rename(|prefix) =
    try(
        where(prefix' := <concat-strings> [prefix, "_"])
      ; where(not(string-starts-with(|prefix')))
      ; <concat-strings; newname-webdsl> [prefix', <id>]
  )

rules // toplevel-rename: return name prefixed with toplevel definition

  toplevel-rename = prefix-rename(|<TopLevelDefineName>)
