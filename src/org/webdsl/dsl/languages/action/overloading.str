module org/webdsl/dsl/languages/action/overloading
 
rules 

  /**
   *  overloading resolution (currently used for global functions and templates)
   *  assumes options have the same name (wrong arity is filtered here, so are doubles)
   *  t_target : list of types, the types of the call being resolved
   *  x: the name, only used to connect an error message in a dyn rule
   *  a@[x|xs] : list of list of types, the options available
   *  
   */
  find-most-specific-signature(|t_target,xnew): 
    a@[x|xs] -> result //t_arg*
    where arity := <length> t_target
        ; distances := <filter(where(length;?arity));make-set;map(find-most-specific-signature-helper(|t_target))> a
        //remove impossible matches (indicated by -1), then find most specific
        ; {| MostSpecificFunction : 
             <filter(not(fetch(?-1)));map(compare-distances-for-overloading)> distances
           ; resultarglists := <bagof-MostSpecificFunction> //fails if none was applicable
           ; not([] := resultarglists) //none of the signatures match
           ; (  [y{result}] := resultarglists
             <+ <error-in-overload-resolution-multiple> (xnew,resultarglists) 
             )
          |}
          
  error-in-overload-resolution-multiple:
    (x,resultarglists) -> <fail>
    with  if not(InTypeCheckingPhase) then //if no longer typechecking this is an error in the compiler
            <debug> "Error found during compilation: conflicting signatures in overload resolution "
          ; <debug> (x,resultarglists)
          ; <exit> 1
          else
            errormessage := ["overload resolution failed for ",x,", conflicting signatures: ", resultarglists]
          ; rules(ErrorDuringOverloadResolution : x -> errormessage)
          end
       
rules       
       
  find-most-specific-signature-helper(|t_target):    
    t_check -> result{t_check}
    where comparisontuple := (<map(try(remove-sort-constructor))> t_target, <map(try(remove-sort-constructor))> t_check)
        ; newlist := <zip(count-number-of-extends-traversals)> comparisontuple
        ; result := newlist // EV: why this binding?

rules

  /**
   *  Currently, simplesort types extends checks are based on the string. But GenericSort
   *  uses the constructor and not a string representation to keep them separated.
   */
  //remove-sort-constructor-warn= remove-sort-constructor <+ debug(!"warning: cannot extract sort for this type, reverting to basic overloaded function lookup, ie exact match of argument types") 
  remove-sort-constructor : SimpleSort(s) -> s
  //remove-sort-constructor : GenericSort(coltype,[SimpleSort(s)]) -> s

rules

  /**
   *  count-number-of-extends-traversals:
   *  Receives a tuple of types, where the left value is the type in the call and the right value
   *  is the type in the definition. If they don't match, then the left value is replaced by its
   *  super type and a counter is increased until left and right match. When "Object" is reached on the left,
   *  either the types did not match or the right also had "Object". The result is a number which 
   *  indicates the distance between the call and definition types or -1 if they did not match at all.
   */

  count-number-of-extends-traversals =
    count-number-of-extends-traversals(|0)

  count-number-of-extends-traversals(|n) :
    ("Object", t) -> -1  //not matching at all
    where not(t := "Object")

  count-number-of-extends-traversals(|n) :
    (t,t) -> n
    
  count-number-of-extends-traversals(|n) :
    (t_target,t_check) -> 
      <count-number-of-extends-traversals(|<inc>n)> (<extends-check> t_target,t_check)
    where not(t_target := t_check)
        // extends-check only goes one superclass higher
      
rules
  
  compare-distances-for-overloading:
    x -> x
    where if not(MostSpecificFunction)
          then rules (MostSpecificFunction :+= x)
          else 
            if <map(is-more-specific-function(|x))> <bagof-MostSpecificFunction>
            then repeat(once-MostSpecificFunction);rules (MostSpecificFunction :+= x)
            else 
              if not(<map(is-less-specific-function(|x))> <bagof-MostSpecificFunction>)
              then rules (MostSpecificFunction :+= x)
              end
            end
          end
          
  is-more-specific-function(|new)=
    ?current
  ; !(new,current)
  ; zip(leq)
  
  is-less-specific-function(|new)=
    ?current
  ; !(new,current)
  ; zip(geq)
