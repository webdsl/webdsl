module org/webdsl/dsl/to-java-servlet/hibernate-util

imports
  libstratego-lib
  libjava-front

imports
  libwebdsl-front

overlays

  e_HibSession() =
    java:expr |[ utils.HibernateUtil.getCurrentSession() ]|

rules

  hibernate-forall-criteria :
    (term{anno*}, t, x, srt, fltr, prefetch) -> e_criteria
    with e_basecriteria := <try(hibernate-add-cacheable(|anno*))> expr|[ ~e:(e_HibSession()).createCriteria(t.class) ]|
    ; toonejoins := <is-guided-batching-no-joins < get-alias-joins + get-to-one-joins> prefetch
    ; QueryCondition(querycondition) := <fetch-elem(?QueryCondition(_)) <+ !QueryCondition(True())> anno*
    ; e_criteria := <foldr(!e_basecriteria,hibernate-criteria-join); hibernate-criteria-add-condition(|querycondition,x,srt)> toonejoins
        //try on next line since not all ordering can be translated to query
        /** ; e_criteria := <foldr(!e0,hibernate-forall-criteria-filter(|x,srt));where(rules(OrderAndLimitApplied:=True())) <+ !e0> [lim,ob]  */

  hibernate-add-cacheable(|anno*) :
    e -> expr |[ e.setCacheable(true) ]|
    where <fetch-elem(?CachedEntity())> anno*

  condition-to-query-string(|x) :
    FieldAccess(p, f) -> expr |[ "~str" ]|
    where <collect(?Var(x)); not(?[])> p
    with alias := <property-to-alias> p
    ; if alias := "" then
        str := <concat-strings> ["_", f]
      else
        str := <concat-strings> [alias, "._", f]
      end

  try-get-query-condition-filter = get-anno(get-query-condition-filter) <+ !([], [])

  get-query-condition-filter :
    QueryConditionFilter(name, vars, types) -> (bstm* |[ e_expr; ]|, bstm* |[ ~e:(e_HibSession()).disableFilter("~name"); ]|)
    with params := <zip>(<length; range> types, <zip> (vars, types))
    ; e_expr := <foldr(!expr |[ ~e:(e_HibSession()).enableFilter("~name") ]|, add-filter-param)> params

  add-filter-param :
    ((i, (v, srt)), e) -> expr |[ e.setParameter("~name", new x(e_val)) ]|
    with name := <concat-strings> ["param", <int-to-string> i]
    ; x := <java-type-name> srt
    ; e_val := <expression-to-java-servlet> v

  hibernate-criteria-join :
      (str{anno*}, e) -> expr|[ e.setFetchMode("~str", org.hibernate.FetchMode.JOIN) ]|
      where not(<fetch-elem(?RequiresAlias())> anno*)

  hibernate-criteria-join :
    (str{anno*}, e) -> expr|[ e.createAlias("~str", "~alias", org.hibernate.criterion.CriteriaSpecification.LEFT_JOIN) ]|
    where <fetch-elem(?RequiresAlias())> anno*
    with alias := <join-fetch-to-alias> str

  hibernate-criteria-add-condition(|cond,x,srt) :
      e_criteria -> <id>
      where <?True()> cond

  hibernate-criteria-add-condition(|cond,x,srt) :
      e_criteria -> expr|[ e_criteria.add(e_Cond) ]|
      where not(True() := cond)
      with e_Cond := <hibernate-criteria-transform-condition(|x,srt)> cond

  hibernate-criteria-transform-condition(|x,srt):
    Not(expr1) -> expr|[ org.hibernate.criterion.Restrictions.not(e_expr1new) ]|
    with e_expr1new := <hibernate-criteria-transform-condition(|x,srt)> expr1

  hibernate-criteria-transform-condition(|x,srt):
    Or(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.or(e_expr1new, e_expr2new) ]|
    with e_expr1new := <hibernate-criteria-transform-condition(|x,srt)> expr1
    ; e_expr2new := <hibernate-criteria-transform-condition(|x,srt)> expr2

  hibernate-criteria-transform-condition(|x,srt):
    And(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.and(e_expr1new, e_expr2new) ]|
    with e_expr1new := <hibernate-criteria-transform-condition(|x,srt)> expr1
    ; e_expr2new := <hibernate-criteria-transform-condition(|x,srt)> expr2

  hibernate-criteria-transform-condition(|x,srt):
    SmallerThanOrEqual(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.leProperty(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-both-props(|x,srt)>(expr1, expr2) // Both expressions are database fields

  hibernate-criteria-transform-condition(|x,srt):
    SmallerThanOrEqual(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.le(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-param1-prop(|x,srt)>(expr1, expr2) // expr1 is a database field, expr2 is not

  hibernate-criteria-transform-condition(|x,srt):
    SmallerThanOrEqual(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.gt(e_expr2new, e_expr1new) ]|
    where (e_expr1new, e_expr2new) := <transform-param2-prop(|x,srt)>(expr1, expr2) // expr2 is a database field, expr1 is not

  hibernate-criteria-transform-condition(|x,srt):
    SmallerThan(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.ltProperty(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-both-props(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    SmallerThan(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.lt(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-param1-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    SmallerThan(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.ge(e_expr2new, e_expr1new) ]|
    where (e_expr1new, e_expr2new) := <transform-param2-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    LargerThanOrEqual(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.geProperty(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-both-props(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    LargerThanOrEqual(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.ge(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-param1-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    LargerThanOrEqual(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.lt(e_expr2new, e_expr1new) ]|
    where (e_expr1new, e_expr2new) := <transform-param2-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    LargerThan(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.gtProperty(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-both-props(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    LargerThan(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.gt(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-param1-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    LargerThan(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.le(e_expr2new, e_expr1new) ]|
    where (e_expr1new, e_expr2new) := <transform-param2-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    NotEq(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.neProperty(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-both-props(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    NotEq(expr1, expr2) -> expr|[ utils.QueryOptimization.getNotEqCondition(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-param1-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    NotEq(expr1, expr2) -> expr|[ utils.QueryOptimization.getNotEqCondition(e_expr2new, e_expr1new) ]|
    where (e_expr1new, e_expr2new) := <transform-param2-prop(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    Eq(expr1, expr2) -> expr|[ org.hibernate.criterion.Restrictions.eqProperty(e_expr1new, e_expr2new) ]|
    where (e_expr1new, e_expr2new) := <transform-both-props(|x,srt)>(expr1, expr2)

  hibernate-criteria-transform-condition(|x,srt):
    Eq(expr1{anno*}, expr2) -> expr|[ utils.QueryOptimization.getEqCondition(e_expr1new, e_expr2new, e_naturalId) ]|
    where (e_expr1new, e_expr2new) := <transform-param1-prop(|x,srt)>(expr1, expr2)
    ; e_naturalId := <fetch-elem(?IsNaturalId()) < !expr|[true]| + !expr|[false]|> anno*

  hibernate-criteria-transform-condition(|x,srt):
    Eq(expr1, expr2{anno*}) -> expr|[ utils.QueryOptimization.getEqCondition(e_expr2new, e_expr1new, e_naturalId) ]|
    where (e_expr1new, e_expr2new) := <transform-param2-prop(|x,srt)>(expr1, expr2)
    ; e_naturalId := <fetch-elem(?IsNaturalId()) < !expr|[true]| + !expr|[false]|> anno*

  transform-both-props(|x,srt):
      (expr1, expr2) -> (e_expr1new, e_expr2new)
    where not([] := <collect(?Var(x))>expr1); not([] := <collect(?Var(x))>expr2)
    with e_expr1new := <condition-to-query-string(|x)> expr1
    ; e_expr2new := <condition-to-query-string(|x)> expr2

  transform-param1-prop(|x,srt):
    (expr1, expr2) -> (e_expr1new, e_expr2new)
    where not([] := <collect(?Var(x))>expr1); [] := <collect(?Var(x))>expr2
    with e_expr1new := <condition-to-query-string(|x)> expr1
    ; e_expr2new := <expression-to-java-servlet> expr2

  transform-param2-prop(|x,srt):
    (expr1, expr2) -> (e_expr2new, e_expr1new)
    where [] := <collect(?Var(x))>expr1; not([] := <collect(?Var(x))>expr2)
    with e_expr1new := <expression-to-java-servlet> expr1
    ; e_expr2new := <condition-to-query-string(|x)> expr2


/*  get-to-one-nodes(|x) = ?PrefetchFor(_, _, _, <get-prefetch-children>); get-to-one-nodes(|x)
  get-to-one-nodes(|x) = ?None(); ![]
  get-to-one-nodes(|x) = is-list; filter(get-join-nodes-helper(?PrefetchNode(_, _{PrefetchPropAnno(_,<id>)}, _, _, _, _, _); not(is-generic-sort)|x,"_")); flatten-list

  remove-all-fa = ?Int(_)
  remove-all-fa = ?Long(_)
  remove-all-fa = ?Float(_)
  remove-all-fa = ?String(_)
  remove-all-fa = ?True()
  remove-all-fa = ?False()
  remove-all-fa = ?Null()
  remove-all-fa = ?Var(_)

  remove-all-fa =
    ?c#([expr1, expr2])
    ; where(<is-query-condition-comparator-cons-name> c)
    ; (all(remove-all-fa) <+ !True())

  remove-all-fa :
    Not(True()) -> Not(True())

  remove-all-fa :
    Not(expr) -> True()
    where not(True() := expr)
    ; True() := <remove-all-fa <+ !True()> expr

  remove-all-fa :
    Not(expr1) -> Not(expr2)
    where expr2 := <remove-all-fa> expr1
    ; not(True() := expr2)

  remove-all-fa :
    c1@And(expr1, expr2) -> c2
    where c2 := <all(remove-all-fa <+ !True()); try(?And(True(), <id>) <+ ?And(<id>, True()))> c1

  remove-all-fa :
    c1@Or(expr1, expr2) -> c2
    where c2 := <all(remove-all-fa <+ !True()); try(\Or(True(), _) -> True()\); try(\Or(_, True()) -> True()\)>c1

  remove-var-conditions = alltd(remove-var-conditions2)

  remove-var-conditions2 :
    PrefetchCondition(expr1) -> PrefetchCondition(expr2)
    with expr2 := <remove-var-conditions-helper> expr1

  remove-var-conditions-helper :
    c#([expr1, expr2]) -> True()
    where <is-query-condition-comparator-cons-name> c
    ; ((Var(_) := expr1) <+ (Var(_) := expr2))

  remove-var-conditions-helper =
    ?c#([expr1, expr2])
    ; where(<is-query-condition-comparator-cons-name> c
      ; not((Var(_) := expr1) <+ (Var(_) := expr2))
      )

  remove-var-conditions-helper :
    Not(True()) -> Not(True())

  remove-var-conditions-helper :
    Not(expr) -> True()
    where not(True() := expr)
    ; True() := <remove-var-conditions-helper <+ !True()> expr

  remove-var-conditions-helper :
    Not(expr1) -> Not(expr2)
    where expr2 := <remove-var-conditions-helper> expr1
    ; not(True() := expr2)

  remove-var-conditions-helper :
    c1@And(expr1, expr2) -> c2
    with c2 := <all(remove-var-conditions-helper <+ !True()); try(?And(True(), <id>) <+ ?And(<id>, True()))> c1

  remove-var-conditions-helper :
    c1@Or(expr1, expr2) -> c2
    with c2 := <all(remove-var-conditions-helper <+ !True()); try(\Or(True(), _) -> True()\); try(\Or(_, True()) -> True()\)>c1

  get-join-nodes-helper(s|x,prefix) :
    PrefetchNode(_, f, _, _, cond, _, children){anno*} -> [bstmAdd | subjoins]
    where s
    with cond2 := <?PrefetchCondition(<id>) <+ !True()> cond
    ; e_Cond := <(remove-all-fa <+ (debug(!"fail:"); fail)); expression-to-java-servlet> cond2
    ; join := <concat-strings> [prefix, f]//<concat-strings> [prefix, <("" := prefix) < !"_" + !"._">, f]
    ; newprefix := <concat-strings> [join, "._"]
    ; subjoins := <get-prefetch-children; filter(get-join-nodes-helper(s|x,newprefix)); flatten-list> children
    ; if expr |[ true ]| := e_Cond then
        bstmAdd := bstm |[ x.add("~join"); ]|
      else
        bstmAdd := bstm |[ if(e_Cond) x.add("~join"); ]|
      end
*/

  use-conditions-without-vars = topdown(try(replace-condition-to-condition-without-vars))

  replace-condition-to-condition-without-vars :
    PrefetchWhere(pwmod*,cond{condanno*}){pwanno*} -> PrefetchWhere(pwmod*,cond2){pwkeepanno*}
    with pwkeepanno* := <remove-all(?QueryConditionFilter(_, _, _)); map(try(?ConditionWithoutVars(fltr); !fltr))> pwanno*
    ; cond2 := <fetch-elem(?ConditionWithoutVars(<id>)) <+ !True()> condanno*

  replace-condition-to-condition-without-vars :
    PrefetchCondition(cond1){anno*} -> PrefetchCondition(cond2){anno*}
    with ConditionWithoutVars(cond2) := <get-anno(?ConditionWithoutVars(_))> cond1

  get-to-one-joins-no-empty-batch = ?PrefetchFor(_, _, _, <get-prefetch-children>); get-to-one-joins-no-empty-batch
  get-to-one-joins-no-empty-batch = ?None(); ![]
  get-to-one-joins-no-empty-batch = is-list; filter(get-joins-no-empty-batch-helper(|"_")); flatten-list

  get-joins-no-empty-batch-helper(|prefix) :
    pn@PrefetchNode(_, f, mod*, _, _, _, children){anno*} -> [join{joinanno*} | subjoins]
    where <?PrefetchNode(_, _{PrefetchPropAnno(_,<id>)}, _, _, _, _, _); not(is-generic-sort)> pn
    ; <fetch-elem(?NoEmptyBatch())> mod*
    with join := <concat-strings> [prefix, f]
    ; newprefix := <concat-strings> [join, "._"]
    ; subjoins := <get-prefetch-children; filter(get-joins-no-empty-batch-helper(|newprefix)); flatten-list> children
    ; joinanno* := <get-requires-alias-anno> (anno*, subjoins)
/*
  get-joins-no-empty-batch-helper(|prefix) :
    pn@PrefetchNode(_, f, mod*, _, _, _, children){anno*} -> [join{joinanno*} | subjoins]
    where <?PrefetchNode(_, _{PrefetchPropAnno(_,<id>)}, _, _, _, _, _); not(is-generic-sort)> pn
    ; <not(fetch-elem(?NoEmptyBatch()))> mod*
    with join := <concat-strings> [prefix, f]
    ; newprefix := <concat-strings> [join, "._"]
    ; subjoins := <get-prefetch-children; filter(get-joins-no-empty-batch-helper(|newprefix)); flatten-list> children
    where not([] := subjoins)
    with joinanno* := <get-requires-alias-anno> (anno*, subjoins)*/

  get-to-one-joins = ?PrefetchFor(_, _, _, <get-prefetch-children>); get-to-one-joins
  get-to-one-joins = ?None(); ![]
  get-to-one-joins = is-list; filter(get-joins-helper(?PrefetchNode(_, _{PrefetchPropAnno(_,<id>)}, _, _, _, _, _); not(is-generic-sort)|"_")); flatten-list
  get-alias-joins = get-to-one-joins; filter(?_{RequiresAlias()})

  get-joins-helper(s|prefix) :
    PrefetchNode(_, f, _, _, _, _, children){anno*} -> [join{joinanno*} | subjoins]
    where s
    with join := <concat-strings> [prefix, f]//<concat-strings> [prefix, <("" := prefix) < !"_" + !"._">, f]
    ; newprefix := <concat-strings> [join, "._"]
    ; subjoins := <get-prefetch-children; filter(get-joins-helper(s|newprefix)); flatten-list> children
    ; joinanno* := <get-requires-alias-anno> (anno*, subjoins)

  get-requires-alias-anno :
    (anno*, subjoins) -> []
    where <not(fetch-elem(?RequiresAlias()))> anno*
    ; <not(fetch-elem(?_{RequiresAlias()}))> subjoins

  get-requires-alias-anno :
    (anno*, subjoins) -> [RequiresAlias()]
    where <fetch-elem(?RequiresAlias())> anno*

  get-requires-alias-anno :
    (anno*, subjoins) -> [RequiresAlias()]
    where <fetch-elem(?_{RequiresAlias()})> subjoins

  add-direct-fetches(|e_criteria) :
    PrefetchFor(_, _, _, PrefetchChildren(tree)) -> e_newcriteria
    with toonejoins := <get-to-one-joins> tree
    ; e_newcriteria := <foldr(!e_criteria, \ (str, e) -> expr |[ e.setFetchMode("~str", org.hibernate.FetchMode.JOIN) ]| \)> toonejoins

  get-direct-fetches :
    prefetch -> e_joins
    with e_joins := <get-to-one-joins; string-list-to-java-servlet-or-null> prefetch

  get-direct-fetches-no-empty-batch :
    prefetch -> e_joins
    with e_joins := <get-to-one-joins-no-empty-batch; string-list-to-java-servlet-or-null> prefetch

  get-direct-fetches-if-join-fetching = use-join-fetching < get-direct-fetches + !expr|[(String[])null]|

  get-batch-fetches(|e_LocalHibSession, x_list, srt) =
    ?PrefetchFor(_, templ, _, <get-prefetch-children>)
    ; bstm_sub* := <start-build-sub-batches(|e_LocalHibSession, x_list, srt)>
    ; bstm_templ* := <get-prefetch-for-template-at-root(|x_list, srt) <+ ![]> templ
    ; <if-optimization-enabled> bstm* |[ ~bstm*:bstm_templ* ~bstm*:bstm_sub* ]|

  get-prefetch-for-template-at-root(|x_list, srt) =
    ?templ
    ; SimpleSort(_) := srt
    ; <get-prefetch-for-template(|x_list)> templ

  get-prefetch-for-template-at-root(|x_list, srt) =
    ?templ
    ; GenericSort(_, _) := srt
    ; elemsrt := <get-inner-most-batch-sort> srt
    ; t := <java-type> elemsrt
    ; x_batchelem := <newname-webdsl> "elem"
    ; x_batch := <newname-webdsl> "batch"
    ; bstm_decl := bstm |[ java.util.ArrayList<t> x_batch = new java.util.ArrayList<t>(); ]|
    ; bstm_add* := <loops-for-generic-batches(|x_batchelem, bstm* |[ x_batch.add(x_batchelem); ]|)> (x_list, srt)
    ; bstm_templ* := <get-prefetch-for-template(|x_batch)> templ
    ; !bstm* |[ bstm_decl ~bstm*:bstm_add* ~bstm*:bstm_templ* ]|

  if-optimization-enabled : bstm* -> [] where [] := <flatten-list>bstm*
  if-optimization-enabled : bstm* -> bstm* |[ if(utils.QueryOptimization.isOptimizationEnabled()){ bstm* } ]| where not([] := <flatten-list>bstm*) // bstm* can be [[]]

  get-batch-fetches-single-simple-this =
    ?PrefetchFor(v, _, _, <get-prefetch-children>)
    ; filter(get-batch-fetches-single-simple-this-helper(|v))

  // No castsrt is allowed, because properties of sub-classes are only accessible through the getter, but this may initialize NO_PROXY properties
  // Collections properties are also not prefetched, because that is left for a later for-loop
  get-batch-fetches-single-simple-this-helper(|v) :
    PrefetchNode(None(), f{PrefetchPropAnno(decsrt, fsrt@SimpleSort(_))}, mod*, templ, cond, elemcond, children){anno*} -> bstm* |[ if(x instanceof org.hibernate.proxy.HibernateProxy && ((org.hibernate.proxy.HibernateProxy)x).getHibernateLazyInitializer().isUninitialized()) utils.QueryOptimization.prefetchEntity(utils.HibernateUtil.getCurrentSession(), "~str", (org.hibernate.proxy.HibernateProxy)x, e_joins); ]|
    where x := <concat-strings>["_", f]
    ; str := <java-type-name> fsrt
    ; e_joins := <get-prefetch-children; get-direct-fetches-no-empty-batch; not(?expr |[ (String[])null ]|)> children

  get-batch-fetches-single-this =
      ?PrefetchFor(v, _, _, <get-prefetch-children>)
      ; map(get-batch-fetches-single-this-helper(|v))

  get-batch-fetches-single-this-helper(|v) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt@SimpleSort(_))}, mod*, templ, cond, elemcond, children){anno*} -> bstm* |[
                                            if(e_Cond && utils.QueryOptimization.isOptimizationEnabled()) {
                                              java.util.ArrayList<t> x_list = new java.util.ArrayList<t>();
                                              x_list.add(e_expr);
                                              utils.QueryOptimization.prefetchEntities(~e:(e_HibSession()), "~str", x_list, e_joins, false);
                                              ~bstm*:bstm_sub*
                                            }
                                          ]|
    where x := f
    ; t := <java-type> fsrt
    ; str := <java-type-name> fsrt
    ; x_list := <concat-strings; newname-webdsl>[x, "Lst"]
    ; e_joins := <get-prefetch-children; get-direct-fetches> children
    ; bstm_sub* := <get-prefetch-children; start-build-sub-batches(|e_HibSession(), x_list, fsrt)> children
    ; if Some(simplecastsrt@SimpleSort(x_castclass)) := castsrt then
        e_expr := <expression-to-java-servlet> FieldAccess(Cast(v, simplecastsrt), f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ this.instanceOf("~x_castclass") && e_expr != null ]|
      else
        e_expr := <expression-to-java-servlet> FieldAccess(v, f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ e_expr != null ]|
      end

  get-batch-fetches-single-this-helper(|v) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt@GenericSort(_, [fsimplesrt]))}, mod*, templ, cond, elemcond, children){anno*} -> bstm* |[
                                            if(e_Cond && utils.QueryOptimization.isOptimizationEnabled()) {
                                              java.lang.Iterable<t> x_list = e_expr;
                                              ~bstm*:bstm_sub*
                                            }
                                          ]|
    where x := f
    ; t := <java-type> fsimplesrt
    ; x_list := <concat-strings; newname-webdsl>[x, "Lst"]
    ; bstm_sub* := <get-prefetch-children; start-build-sub-batches(|e_HibSession(), x_list, fsimplesrt)> children
    ; if Some(simplecastsrt@SimpleSort(x_castclass)) := castsrt then
        e_expr := <expression-to-java-servlet> FieldAccess(Cast(v, simplecastsrt), f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ this.instanceOf("~x_castclass") && e_expr != null ]|
      else
        e_expr := <expression-to-java-servlet> FieldAccess(v, f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ e_expr != null ]|
      end

  get-batch-fetches-single(|x, srt) :
    PrefetchFor(_, _, _, tree) -> bstm* |[
                                            if(x != null) {
                                              java.util.ArrayList<t> x_list = new java.util.ArrayList<t>();
                                              x_list.add(x);
                                              utils.QueryOptimization.prefetchEntities(~e:(e_HibSession()), "~str", x_list, e_joins, false);
                                              ~bstm*:bstm_sub*
                                            }
                                          ]|
    where t := <java-type> srt
    ; str := <java-type-name> srt
    ; e_joins := <get-prefetch-children; get-direct-fetches> tree
    ; x_list := <concat-strings; newname-webdsl>[x, "Lst"]
    ; bstm_sub* := <get-prefetch-children; start-build-sub-batches(|e_HibSession(), x_list, srt)> tree

  get-batch-fetches-single-simple(|x, srt) :
    PrefetchFor(_, _, _, tree) -> bstm* |[
                                    if(x instanceof org.hibernate.proxy.HibernateProxy) utils.QueryOptimization.prefetchEntity(~e:(e_HibSession()), "~str", (org.hibernate.proxy.HibernateProxy)x, e_joins);
                                  ]|
    where str := <java-type-name> srt
    ; e_joins := <get-prefetch-children; get-direct-fetches-no-empty-batch; not(?expr |[ (String[])null ]|)> tree // If no joins are present then this would just be a hibSession.get()

  get-batch-fetches-filter-hints(|x, srt) :
    PrefetchFor(_, _, _, tree) -> bstm*
    where bstm* := <get-first-generic-fetches-with-hints; map(build-prefetch-hint(|x,srt)); if-optimization-enabled> tree

  get-first-generic-fetches-with-hints =
      get-prefetch-children
      ; filter(get-first-generic-fetches-with-hints-helper)

  get-first-generic-fetches-with-hints-helper :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, elemcond, children){anno*} -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, elemcond, PrefetchChildren(newchildren)){anno*}
    where not(GenericSort(_, [_]) := fsrt)
    ; newchildren := <get-prefetch-children; filter(get-first-generic-fetches-with-hints-helper); concat> children
    ; not([] := newchildren)

  get-first-generic-fetches-with-hints-helper :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, pw@PrefetchWhere(pwmod*, _){pwanno*}, children){anno*} -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, pw{pwanno*}, None()){anno*}
    where GenericSort(_, [_]) := fsrt
    ; <fetch-elem(?Hint())> pwmod*
    ; <fetch-elem(?QueryConditionFilter(_, _, _))> pwanno*

  get-early-batch-fetches(|e_LocalHibSession, x_list, srt) =
    ?PrefetchFor(_, _, _, <get-prefetch-children>)
    ; filter(get-fetch-early-subtree)
    ; start-build-sub-batches(|e_LocalHibSession, x_list, srt)
    ; if-optimization-enabled

  // This node is a prefetch-early node, so include
  get-fetch-early-subtree :
    PrefetchNode(castsrt, f, mod*, templ, cond, elemcond, children){anno*} -> PrefetchNode(castsrt, f, mod*, templ, cond, elemcond, newchildren){anno*}
    where <is-fetch-early> mod*
    ; newchildren := <get-prefetch-children; filter(get-fetch-early-subtree); wrap-prefetch-children> children

  // This node is not a prefetch-early node, but can be included if a child node is a prefetch-early node
  get-fetch-early-subtree :
    PrefetchNode(castsrt, f, mod*, templ, cond, elemcond, children){anno*} -> PrefetchNode(castsrt, f, mod*, templ, cond, elemcond, PrefetchChildren(newchildren)){anno*}
    where <not(is-fetch-early)> mod*
    ; newchildren := <get-prefetch-children; filter(get-fetch-early-subtree)> children
    ; not([] := newchildren)

  build-prefetch-hint(|x_elem,elemsrt) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, elemcond, children){anno*} -> bstm_addhints*
    where SimpleSort(x_class) := fsrt
    with v := Var(x_elem){TypeAnno(elemsrt)}
    ; x_nextelem := <newname-webdsl> "elem"
    ; bstm* := <get-prefetch-children; map(build-prefetch-hint(|x_nextelem,fsrt))> children
    ; if Some(simplecastsrt@SimpleSort(x_castclass)) := castsrt then
        e_expr := <expression-to-java-servlet> FieldAccess(Cast(v, simplecastsrt), f)
        ; bstm_addhints* := bstm* |[
            if (x_elem.instanceOf("~x_castclass")) {
              x_class x_nextelem = e_expr;
              bstm*
            }
          ]|
      else
        e_expr := <expression-to-java-servlet> FieldAccess(v, f)
        ; bstm_addhints* := bstm* |[
            x_class x_nextelem = e_expr;
            bstm*
          ]|
      end

  // Also check for (getFilterHint() == null), to avoid the creation of extra FilterImpl objects by e_fltr
  build-prefetch-hint(|x_elem,elemsrt) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, elemcond, children){anno*} -> bstm* |[ if(e_cond) { ~bstm*:bstm_sethint* } ]|
    where GenericSort(_, [_]) := fsrt
    with v := Var(x_elem){TypeAnno(elemsrt)}
    ; if Some(simplecastsrt@SimpleSort(x_castclass)) := castsrt then
        e_expr := <expression-to-java-servlet> FieldAccess(Cast(v, simplecastsrt), f)
        ; e_cond := expr |[ x_elem.instanceOf("~x_castclass") && e_expr instanceof utils.PersistentOwnedCollection && !((utils.PersistentOwnedCollection)e_expr).wasInitialized() && ((utils.PersistentOwnedCollection)e_expr).getFilterHint() == null ]|
      else
        e_expr := <expression-to-java-servlet> FieldAccess(v, f)
        ; e_cond := expr |[ e_expr instanceof utils.PersistentOwnedCollection && !((utils.PersistentOwnedCollection)e_expr).wasInitialized() && ((utils.PersistentOwnedCollection)e_expr).getFilterHint() == null ]|
      end
    ; bstm_sethint* := <get-query-condition-filter-hint(|e_expr)> elemcond

  get-query-condition-filter-hint(|e_expr) :
    PrefetchWhere(pwmod*, cond){anno*} -> bstm* |[
      org.hibernate.impl.FilterImpl x_fltr = new org.hibernate.impl.FilterImpl(utils.HibernateUtil.getSessionFactory.getFilterDefinition("~name"));
      e_setparams;
      ((utils.PersistentOwnedCollection)e_expr).setFilterHint(x_fltr);
    ]|
    where <fetch-elem(?Hint())> pwmod*
    ; <fetch-elem(?QueryConditionFilter(name, vars, types))> anno*
    with params := <zip>(<length; range> types, <zip> (vars, types))
    ; x_fltr := <newname-webdsl> "fltr"
    ; e_setparams := <foldr(!expr |[ x_fltr ]|, add-filter-param)> params

  get-generic-batch-fetches(|e_LocalHibSession, x_list, srt) =
    ?PrefetchFor(_, _, _, <get-prefetch-children>)
    ; (is-guided-batching-no-joins <+ filter(has-generic-batch-fetch))
    ; start-build-sub-batches(|e_LocalHibSession, x_list, srt)
    ; if-optimization-enabled

  has-generic-batch-fetch = where(?PrefetchNode(_, _{PrefetchPropAnno(_,<id>)}, _, _, _, _, _); is-generic-sort)

  has-generic-batch-fetch :
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, mod*, deftempl, cond, elemcond, children){anno*} ->
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, mod*, deftempl, cond, elemcond, PrefetchChildren(newchildren)){anno*}
    where not(<is-generic-sort> fsrt)
    ; newchildren := <get-prefetch-children; filter(has-generic-batch-fetch)> children
    ; not([] := newchildren)

  truncate-keep-right(|len) = where(!(<strlen>, len); not(gt))

  truncate-keep-right(|len) = where(!(<strlen>, len); gt); explode-string; reverse; take(|85); reverse; implode-string; <concat-strings> ["truncated_", <id>] // add truncated prefix, to ensure identifiers still start with a letter

  get-inner-most-batch-sort = ?SimpleSort(_) <+ ?GenericSort(_, [<get-inner-most-batch-sort>])

  loops-for-generic-batches(|x_batchelem, bstm_op*) :
    (x_list, srt@SimpleSort(_)) -> bstm* |[
        for(t x_batchelem : x_list) {
          if(x_batchelem == null) continue;
          ~bstm*:bstm_op*
        }
    ]|
    where t := <java-type> srt

  loops-for-generic-batches(|x_batchelem, bstm_op*) :
    (x_list, srt@GenericSort(_, [simplersort])) -> bstm* |[
        for(t x_elem : x_list) {
          if(x_elem == null) continue;
          ~bstm*:bstm_innerloop*
        }
    ]|
    where t := <java-type> srt
    ; x_elem := <newname-webdsl>"innerlst"
    ; bstm_innerloop* := <loops-for-generic-batches(|x_batchelem, bstm_op*)> (x_elem, simplersort)

  start-build-sub-batches(|e_LocalHibSession, x_list, srt) =
    ?nodes
    ; collect(get-reusable-conditions-from-prefetch-condition)
    ; flatten-list
    ; make-set
    ; {| ReuseExpression
       : map(generate-declare-for-reusable)
       ; ?bstm_reusable*
       ; !nodes
       ; build-sub-batches(|e_LocalHibSession, x_list, srt)
       ; ?bstm_batches*
       |}
    ; try(not(?[]); ![bstm_reusable*,bstm_batches*])

  generate-declare-for-reusable :
    cond -> bstm |[ t x = e; ]|
    with x := <newname-webdsl> "reusable"
    ; e := <expression-to-java-servlet> cond
    ; t := <get-type-anno;java-type> cond
    ; rules( ReuseExpression : cond -> Var(x) )

  get-reusable-conditions-from-prefetch-condition :
    PrefetchCondition(cond) -> reusable
    with reusable := <collect(has-anno(|IsReusableCondition()))> cond

  build-sub-batches(|e_LocalHibSession, x_list, srt) = build-sub-batches(|e_LocalHibSession, x_list, srt, []); Fst

  build-sub-batches(|e_LocalHibSession, x_list, srt, allvars) :
    [] -> ([], allvars, [])

  build-sub-batches(|e_LocalHibSession, x_list, srt, allvars) :
    children -> (bstm* |[
        ~bstm*:bstm_batch*
        ~bstm*:bstm_addloops*
        ~bstm*:bstm_fetch*
        ~bstm*:bstm_after2*
        ~bstm*:bstm_final*
        ~bstm*:bstm_subbatch*
      ]|, newvars, bound)
    with elemsrt := <get-inner-most-batch-sort> srt
    ; x_batchelem := <newname-webdsl> "elem"
    ; (tmp, newvars, bound) := <foldr(!([], allvars, [x_list]), build-batches-from-children(|e_LocalHibSession, x_batchelem, elemsrt, x_list)); (reverse, id, id)> children
    ; bstm_batch* :=    <map(?(<id>, _, _, _, _, _)); flatten-list> tmp
    ; bstm_addbatch* := <map(?(_, <id>, _, _, _, _))> tmp
    ; bstm_fetch* :=    <map(?(_, _, <id>, _, _, _)); flatten-list; combine-fetch-entities-of-same-entity-type> tmp
    ; bstm_after* :=    <map(?(_, _, _, <id>, _, _)); flatten-list> tmp
    ; bstm_final* :=    <map(?(_, _, _, _, <id>, _)); flatten-list> tmp
    ; bstm_subbatch* := <map(?(_, _, _, _, _, <id>)); flatten-list> tmp
    ; bstm_addloops* := <loops-for-generic-batches(|x_batchelem, bstm_addbatch*)> (x_list, srt)
    ; if not([] := bstm_after*); not([] := bstm_subbatch*) then
        bstm_after2* := <loops-for-generic-batches(|x_batchelem, bstm_after*)> (x_list, srt)
      else
        bstm_after2* := []
      end

  get-prefetch-for-template(|x_list) :
    PrefetchTemplateArgs(lst) -> bstm* |[ try{ bstm* } catch(Exception ex) {} ]|
    with bstm* := <map(get-prefetch-for-template(|x_list)); flatten-list> lst

  get-prefetch-for-template(|x_list) :
    TemplateArgOrThis(n, arg){anno*} -> bstm* |[ e_newtemplateinstance.prefetchFor(~i:stri, x_list); ]|
    with <fetch-elem(?TemplateName(genname))> anno*
    ; e_newtemplateinstance := java:expr|[ (utils.TemplateServlet) env.getTemplate("~genname").newInstance() ]|
    ; (i, e) := <add-indices; fetch-elem(?(_, PrefetchThisCast(PrefetchThis(), _)) <+ ?(_, PrefetchThis()))> arg
    ; stri := <int-to-string> i

  add-conditions-to-prefetch(|cond, v) :
    e_Cond -> e_NewCond
    with e_NewCond := <try(add-join-condition(|cond, v))> e_Cond

  add-condition-checks-to-prefetch(|cond, v) :
    stm_Expr -> bstm |[ if(e_JoinCond) stm_Expr ]|
    where e_JoinCond := <get-join-condition(|v)> cond

  build-batches-from-children(|e_LocalHibSession, x_batchelem, elemsrt, x_list) :
    (node, (tmp, allvars, bound)) -> ([res|tmp], newvars, newbound)
    with (res, newvars, newbound) := <build-batch(|e_LocalHibSession, x_batchelem, elemsrt, x_list, allvars, bound)> node

  get-variable-for-batch:
    (t, prefix, allvars, boundvars) -> (bstm |[ t x_name = new x(); ]|, x_name, newallvars)
    with x := <java-type-to-java-name> t
    ; compatvars := <fetch-elem(?(t, prefix, <id>)) <+ ![]> allvars
    where [] := <diff> (compatvars, boundvars) // all compatible variables are bound
    ; x_name := <newname-webdsl> prefix
    ; newallvars := <remove-all(?(t, prefix, _)); ![(t, prefix, [x_name|compatvars])|<id>]> allvars

  get-variable-for-batch:
    (t, prefix, allvars, boundvars) -> (bstm |[ x_name.clear(); ]|, x_name, allvars)
    with compatvars := <fetch-elem(?(t, prefix, <id>)) <+ ![]> allvars
    where [x_name|_] := <diff> (compatvars, boundvars) // There is at least one compatible variable that is free

  combine-fetch-entities-of-same-entity-type :
    bstm_fetch* -> [other*, combinedcalls*] // combinedcalls* is deliberately placed after other*, because other* has lazy and collection batches, while combinedcalls* has regular ToOne batches. Batches in other* have already been checked for initialization, but batches in combinedcalls* are not. So entities fetched/initialized by other* will be automatically excluded from batches in combinedcalls* if combinedcalls* is executed after other*. So it further reduces duplicate fetching.
    with partition(\stm |[ utils.QueryOptimization.prefetchEntities(e_LocalHibSession, e_str, e_batch, e_joins, e_clearEmptyBatch); ]| -> (e_LocalHibSession, e_str, e_batch, e_joins, e_clearEmptyBatch)\)
    ; ?(fetchcalls*, other*)
    ; combinedcalls* := <try-combine-fetch-entities-calls> fetchcalls*

  try-combine-fetch-entities-calls :
    [] -> []

  try-combine-fetch-entities-calls :
    [(e_LocalHibSession, e_str, e_batch, e_joins, e_clearEmptyBatch) | rest] -> [stm |[ utils.QueryOptimization.prefetchEntities(e_LocalHibSession, e_str, e_batch, e_joins, e_clearEmptyBatch); ]| | newrest]
    where not(expr|[(String[])null]| := e_joins)
    with newrest := <try-combine-fetch-entities-calls> rest

  try-combine-fetch-entities-calls :
    lst@[(e_LocalHibSession, e_str, _, expr|[(String[])null]|, _) | _] -> [stm_fetch|rest]
    with (tocombine*, next) := <partition(try-combine-fetch-entities-calls-helper(|e_LocalHibSession, e_str))> lst
    ; if [(e_batch, e_clearEmptyBatch)] := tocombine* then // if there is only once matching batch
        stm_fetch := stm |[ utils.QueryOptimization.prefetchEntities(e_LocalHibSession, e_str, e_batch, (String[])null, e_clearEmptyBatch); ]|
      else // else there are at least two batches to combine
        (batches*, clearEmptyBatches*) := <unzip> tocombine*
        ; e_batches := <expression-list-to-java-servlet(|type|[java.util.Collection]|)> batches*
        ; e_clearEmptyBatches := <expression-list-to-java-servlet(|type|[boolean]|)> clearEmptyBatches*
        ; stm_fetch := stm |[ utils.QueryOptimization.prefetchEntities(e_LocalHibSession, e_str, (java.util.Collection<? extends org.webdsl.WebDSLEntity>[])e_batches, e_clearEmptyBatches); ]|
      end
      ; rest := <try-combine-fetch-entities-calls> next

  expression-list-to-java-servlet(|t) :
    lst -> e_arr
    with x_type := <java-type-to-java-name> t
    ; e_arr := <foldr(!expr |[ new x_type[] {} ]|, {?(e, expr |[ new x_type[] {e_array*} ]|); !expr |[ new x_type[] {e_array*,e} ]|})> lst

  try-combine-fetch-entities-calls-helper(|e_LocalHibSession, e_str) :
    (e_LocalHibSession, e_str, x_batch, expr|[(String[])null]|, e_clearEmptyBatch) -> (x_batch, e_clearEmptyBatch)

  /*
  elemsrt : The sort of x_elem
  decsrt : The subsort of elemsrt that declares f
  castsrt : The sort which x_elem should be cast to (or None), this can also be a subsort of decsrt
  fsrt : The sort of f, which can be a generic-sort
  */
    //fa@FieldAccess(c, _){anno*} -> (fa{anno*}, x_batch, t, bstm_batch, bstm_addbatch, bstm_fetch, [])
  build-batch(|e_LocalHibSession, x_elem, elemsrt, x_list, allvars, bound*):
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, elemcond, children){anno*} -> ((bstm_batch, bstm_addbatch, bstm_fetch*, [], bstm_final*, bstm_sub*), newvars2, [x_batch|[newbound*,bound*]])
    where not(<fetch-elem(?IsLazyFetch())> anno*)
    ; SimpleSort(x_class) := fsrt
    with t := <java-type> fsrt
    ; str := <java-type-name> fsrt
    ; (bstm_batch, x_batch, newvars) := <get-variable-for-batch> (type |[ utils.ProxyHashSet<t> ]|, "batch", allvars, bound*) // Not using a HashSet, because executing hashCode or equals could lazy fetch entities, ideally duplicates should be removed, but they are not
    ; e_joins := <get-prefetch-children; get-direct-fetches-if-join-fetching> children
    //; x_get := <concat-strings>["get", <capitalize-string> f]
    ; v := Var(x_elem){TypeAnno(elemsrt)}
    ; if Some(simplecastsrt@SimpleSort(x_castclass)) := castsrt then
        e_expr := <expression-to-java-servlet> FieldAccess(Cast(v, simplecastsrt), f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ x_elem.instanceOf("~x_castclass") ]|
        ; bstm_addbatch := bstm |[ if (e_Cond) x_batch.add(e_expr); ]|
      else
        e_expr := <expression-to-java-servlet> FieldAccess(v, f)
        ; bstm_addbatch := <try(add-condition-checks-to-prefetch(|cond, v))> bstm |[ x_batch.add(e_expr); ]|
      end
    ; e_clearEmptyBatch := <is-no-empty-batch < !expr|[true]| + !expr|[false]|> mod*
    ; bstm_fetch* := stm |[ utils.QueryOptimization.prefetchEntities(e_LocalHibSession, "~str", x_batch, e_joins, e_clearEmptyBatch); ]|
    ; bstm_final* := <get-prefetch-for-template(|x_batch) <+ ![]> templ
    ; (bstm_sub*, newvars2, newbound*) := <get-prefetch-children; build-sub-batches(|e_LocalHibSession, x_batch, fsrt, newvars)> children

  build-batch(|e_LocalHibSession, x_elem, elemsrt, x_list, allvars, bound*):
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, elemcond, children){anno*} -> ((bstm_batch, bstm_addbatch, bstm_fetch*, bstm_after*, bstm_final*, bstm_sub*), newvars3, [x_ownerids|[newbound*,newbound2*]])
    where <fetch-elem(?IsLazyFetch())> anno*
    ; SimpleSort(x_class) := fsrt
    with t := <java-type> fsrt
    ; str := <java-type-name> decsrt
    ; field := <concat-strings>["_", f]
    ; x_f := <capitalize-string> f
    ; (bstm_batch1, x_batch, newvars) := <get-variable-for-batch> (type |[ java.util.HashSet<t> ]|, "batch", allvars, bound*) // Using an HashSet instead of an ArrayList, because elements that are added are already fetched, so hashCode and equals can be executed without lazy fetching, removing duplicates which are not interesting for batch generation
    ; newbound* := [x_batch|bound*]
    ; (bstm_batch2, x_ownerids, newvars2) := <get-variable-for-batch> (type |[ java.util.HashSet<java.io.Serializable> ]|, "ownerIds", newvars, newbound*)
    ; e_joins := <get-prefetch-children; get-direct-fetches-if-join-fetching> children
    ; bstm_batch := bstm* |[
          bstm_batch1
          bstm_batch2
        ]|
    ; v := Var(x_elem){TypeAnno(elemsrt)}
    ; if Some(simplecastsrt@SimpleSort(x_castclass)) := castsrt then
        e_c := <expression-to-java-servlet> Cast(v, simplecastsrt)
        ; e_expr := <expression-to-java-servlet> FieldAccess(Cast(v, simplecastsrt), f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ x_elem.instanceOf("~x_castclass") ]|
        ; bstm_addbatch := bstm |[ if ( e_Cond && e_c.is#x_f#Uninitialized() ) x_ownerids.add(x_elem.getId()); ]|
        ; bstm_after* := <try(add-no-empty-batch-check-list(|mod*, x_ownerids))> bstm* |[ if (e_Cond) x_batch.add(e_expr); ]|
      else
        e_expr := <expression-to-java-servlet> FieldAccess(v, f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ x_elem.is#x_f#Uninitialized() ]|
        ; bstm_addbatch := bstm |[ if (e_Cond) x_ownerids.add(x_elem.getId()); ]|
        ; bstm_after* := <try(add-condition-checks-to-prefetch(|cond, v));try(add-no-empty-batch-check-list(|mod*, x_ownerids))> bstm* |[ x_batch.add(e_expr); ]|
      end
    ; bstm_fetch* := bstm* |[ utils.QueryOptimization.prefetchLazyProperties(e_LocalHibSession, "~str", "~field", x_ownerids, e_joins); ]|
    ; bstm_final* := <get-prefetch-for-template(|x_batch) <+ ![]> templ
    ; (bstm_sub*, newvars3, newbound2*) := <get-prefetch-children; build-sub-batches(|e_LocalHibSession, x_batch, fsrt, newvars2)> children

  build-batch(|e_LocalHibSession, x_elem, elemsrt, x_list, allvars, bound*):
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt, fsrt)}, mod*, templ, cond, elemcond, children){anno*} -> ((bstm_batch, bstm_addbatch, bstm_fetch*, bstm_after*, bstm_disable*, bstm_sub*), newvars3, [x_ownerids|[newbound*,newbound2*]])
    where GenericSort(_, [fsimplesrt]) := fsrt
    with t_Owner := <java-type> decsrt
    ; t := <java-type> fsimplesrt
    ; (bstm_batch1, x_batch, newvars) := <get-variable-for-batch> (type |[ java.util.HashSet<t> ]|, "batch", allvars, bound*) // Using an HashSet instead of an ArrayList, because elements that are added are already fetched, so hashCode and equals can be executed without lazy fetching, removing duplicates which are not interesting for batch generation
    ; newbound* := [x_batch|bound*]
    ; (bstm_batch2, x_ownerids, newvars2) := <get-variable-for-batch> (type |[ java.util.HashSet<java.io.Serializable> ]|, "ownerIds", newvars, newbound*)
    ; e_joins := <get-prefetch-children; get-direct-fetches-if-join-fetching> children
    ; bstm_batch := bstm* |[ bstm_batch1
                             bstm_batch2
                          ]|
    ; strRole := <concat-strings>[<java-type-name> decsrt, "._", f]
    ; v := Var(x_elem){TypeAnno(elemsrt)}
    ; (bstm_enable*, bstm_disable*) := <try-get-query-condition-filter> elemcond
    ; if Some(simplecastsrt@SimpleSort(x_castclass)) := castsrt then
        e_c := <expression-to-java-servlet> Cast(v, simplecastsrt)
        ; e_expr := <expression-to-java-servlet> FieldAccess(Cast(v, simplecastsrt), f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ x_elem.instanceOf("~x_castclass") ]|
        ; bstm_addbatch := bstm |[ if (e_Cond && e_expr instanceof org.hibernate.collection.PersistentCollection && !((org.hibernate.collection.PersistentCollection)e_expr).wasInitialized()) x_ownerids.add(e_c.getId()); ]|
        ; bstm_after* := <try(add-no-empty-batch-check-list(|mod*, x_ownerids))> bstm* |[ if (e_Cond) x_batch.addAll(e_expr); ]|
      else
        e_expr := <expression-to-java-servlet> FieldAccess(v, f)
        ; e_Cond := <add-conditions-to-prefetch(|cond, v)> expr |[ e_expr instanceof org.hibernate.collection.PersistentCollection && !((org.hibernate.collection.PersistentCollection)e_expr).wasInitialized() ]|
        ; bstm_addbatch := bstm |[ if(e_Cond) x_ownerids.add(x_elem.getId()); ]|
        //; e_Cond2 := <add-conditions-to-prefetch(|cond, v)> expr |[ x_ownerids.size() > 0 ]|
        //; bstm_after* := bstm* |[ if(e_Cond2) x_batch.addAll(e_expr); ]|
        ; bstm_after* := <try(add-condition-checks-to-prefetch(|cond, v)); try(add-no-empty-batch-check-list(|mod*, x_ownerids))> stm |[ x_batch.addAll(e_expr); ]|
      end
    ; bstm_fetchtmp := bstm |[ utils.QueryOptimization.prefetchCollections(e_LocalHibSession, "~strRole", x_ownerids, e_joins); ]|
    ; bstm_fetch* := bstm* |[
        ~bstm*:bstm_enable*
        bstm_fetchtmp
      ]|
    ; bstm_templ* := <get-prefetch-for-template(|x_batch) <+ ![]> templ
    ; bstm_final* := [bstm_disable*,bstm_templ*]
    ; (bstm_sub*, newvars3, newbound2*) := <get-prefetch-children; build-sub-batches(|e_LocalHibSession, x_batch, fsimplesrt, newvars2)> children

  add-no-empty-batch-check-list(|mod*, x_list) :
    bstm* |[ if(e_Cond) stm_Expr ]| -> bstm* |[ if(e_Cond && x_list.size() > 0) stm_Expr ]|
    where <is-no-empty-batch> mod*

  add-no-empty-batch-check-list(|mod*, x_list) :
    stm@stm |[ e_Expr; ]| -> bstm* |[ if(x_list.size() > 0) e_Expr; ]|
    where not(stm |[ if(e_Cond) e_SomeExpr; ]| := stm)
    ; <is-no-empty-batch> mod*

  get-join-condition(|v) :
    PrefetchCondition(cond) -> e_JoinCond
    with e_JoinCond := <alltd(ReuseExpression); alltd(replace-relative-fa(|v)); expression-to-java-servlet> cond

  add-join-condition(|cond, v) :
    e_Cond -> expr |[ e_Cond && (e_JoinCond) ]|
    where e_JoinCond := <get-join-condition(|v)> cond

  replace-relative-fa(|v) :
    expr@c#([expr1, expr2]) -> exprwithtypechecks
    where <is-query-condition-comparator-cons-name> c//<elem> (c, ["Eq", "NotEq", "SmallerThan", "SmallerThanOrEqual", "LargerThan", "LargerThanOrEqual"])
    ; newexpr := <all(alltd(replace-relative-fa(|v)))> expr // Replace all relative-fa in subexpression to get casts
    ; [first|other] := <collect(\Cast(e, srt) -> IsA(e, srt)\); make-set> newexpr // Convert the casts to typechecks
    with exprwithtypechecks := <foldr(!And(first,newexpr), \ (check, cond) -> And(check, cond) \)> other // Add the type checks to the condition

  replace-relative-fa(|v) :
    RelativeFieldAccess(castsrt, f) -> FieldAccess(Cast(v, castsrt), f) // A cast in a relative fa is not wrapped in a Some constructor
    where not(None() := castsrt)

  replace-relative-fa(|v) :
    RelativeFieldAccess(None(), f) -> FieldAccess(v, f)

  /**
   * Hibernate optimization below on hold, Zef is working on a replacement ORM
   */
  /*
  hibernate-forall-criteria-filter(|x,srt) = hibernate-forall-criteria-filter

  hibernate-forall-criteria-filter:
    (Limit(limit,first), e) -> expr|[ e.setFirstResult(e_first).setMaxResults(e_limit) ]|
    with  e_limit := <expression-to-java-servlet> limit
        ; e_first := <expression-to-java-servlet> first

  hibernate-forall-criteria-filter(|x,srt) =
    // if the order clause is simply a property, then the query can do the ordering
    hibernate-forall-criteria-order-is-prop(|x,srt)
  <+\(NoOrder(), e) -> e\

  hibernate-forall-criteria-order-is-prop(|x,srt) :
    (OrderDescending(orderexp), e) -> <hibernate-forall-criteria-order-is-prop-helper(|x,srt,"desc")> (orderexp, e)

  hibernate-forall-criteria-order-is-prop(|x,srt) :
    (OrderAscending(orderexp), e) -> <hibernate-forall-criteria-order-is-prop-helper(|x,srt,"asc")> (orderexp, e)

  hibernate-forall-criteria-order-is-prop-helper(|x,srt,x_order) :
    (orderexp, e) -> expr|[ e.addOrder(org.hibernate.criterion.Order.x_order("~<concat-strings> ["_",prop]")) ]|
    with  SimpleSort(ent) := srt
    where FieldAccess(var,prop) := orderexp
        ; Var(x) := var
        ; <type-of-property> (ent,prop)
  */

rules

  generate-code-java-servlet-once =
      all-entity-names := <bagof-AllEntityNames; string-sort-annos>
    ; entity-collection-properties := <bagof-AllEntities; filter(generate-java-servlet-hibernate-util-collection-helper1); flatten-list>
    ; query-optimization-mode := <QueryOptimizationMode>
    ; !(all-entity-names, entity-collection-properties, query-optimization-mode)
      // for the cache to work correctly, code generation should not depend on other information than this current term
    ; disable-code-generation-if-cache-exists
    ; cached-generate(generate-java-servlet-hibernate-util | "internal_HibernateUtil")
    ; fail

  generate-java-servlet-hibernate-util :
    (all-entity-names, entity-collection-properties, query-optimization-mode) -> <emit-java-code-local> compilation-unit|[
    package utils;

    import java.util.Properties;

    import org.hibernate.*;
    import org.hibernate.type.*;
    import org.hibernate.cfg.*;
    import org.webdsl.*;
    import org.hibernate.event.*;
    import org.hibernate.event.def.*;
    import java.util.*;
    import java.io.*;
    import org.hibernate.dialect.Dialect;

    import pkgname.*;
    @SuppressWarnings("unused")
    public class HibernateUtilConfigured extends utils.HibernateUtil{
        private static final SessionFactory configuredSessionFactory ;
        private static Configuration annotationConfiguration;

        static{
          try
          {
            utils.QueryOptimization.optimizationMode = ~i:strOptimizationMode;
            annotationConfiguration = new Configuration();
            ~bstm*:bstm_setprops*

            //Properties prop = HibernateUtil.getProperties();

            annotationConfiguration.addPackage("utils");
            annotationConfiguration.addAnnotatedClass(utils.ApplicationContextProperty.class);
            annotationConfiguration.addAnnotatedClass(utils.File.class);

            annotationConfiguration.addPackage("~domainpack");
            //annotationConfiguration.addAnnotatedClass(User.class);
            bstm*

            //annotationConfiguration.addProperties(prop);
            //bstm1*
            annotationConfiguration.setListener("load", new NarrowProxyByReusingImplementationLoadEventListener());
            annotationConfiguration.setListener("save-update", new SetVersionSaveOrUpdateEventListener());
            annotationConfiguration.setListener("flush-entity", new SetValidationEventListener());
            annotationConfiguration.setListener("auto-flush", new FastAutoFlushEventListener());
            annotationConfiguration.setInterceptor(new WebDSLInterceptor());

            annotationConfiguration.buildMappings();
            bstm1*

            configuredSessionFactory = annotationConfiguration.buildSessionFactory();
            org.webdsl.tools.Utils.handleSchemaCreateUpdate(configuredSessionFactory, annotationConfiguration);
          }
          catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
          }
        }

        protected static SessionFactory getConfiguredSessionFactory() {
            return configuredSessionFactory;
        }

        public static Configuration getAnnotationConfiguration()
        {
          return annotationConfiguration;
        }
     }
    ]|
    with pkgname := <DomainPackage>
       ; domainpack := <pp-java5-to-string> <DomainPackage>
       ; bstm* := <map({\
                           x -> bstm |[ annotationConfiguration.addAnnotatedClass(x_class); ]|
                           where x_class := <concat-strings> [<DomainPackage;pp-java5-to-string>,".",x,".class"]
                       \})> all-entity-names
       ; bstm1* := <filter({\
                                   (x_class, x_coltype, x_prop) -> bstm |[ annotationConfiguration.getCollectionMapping("~strRole").setTypeName("~strType"); ]|
                                   with strRole := <concat-strings> [<DomainPackage;pp-java5-to-string>,".",<capitalize-string>x_class,"._",x_prop]
                                   ; strType := <concat-strings> [<DomainPackage;pp-java5-to-string>,".",<capitalize-string>x_class,<capitalize-string>x_prop, "Owned",x_coltype,"Type"]
                           \})> entity-collection-properties
       ; bstm_setprops* := <is-hibernate-batching(|query-optimization-mode) < !bstm*|[annotationConfiguration.setProperty("hibernate.default_batch_fetch_size", "10");]| + ![]>
       ; strOptimizationMode := <!query-optimization-mode; optimization-mode-to-string>
      /* ; if not([] := <bagof-AllGlobalVars>)
         then bstm1* := [ bstm |[ annotationConfiguration.addAnnotatedClass(ApplicationContextProperty.class); ]| ]
         else bstm1* := [] end
 */

  generate-java-servlet-hibernate-util-collection-helper2(|x_class) :
    Property(x_prop, _, GenericSort(x_coltype, [SimpleSort(_)]), annos) -> (x_class, x_coltype, x_prop)
    where <?"List" <+ ?"Set"> x_coltype; not( <fetch(?SimpleAnno("transient"))>  annos) 

strategies
  generate-java-servlet-hibernate-util-collection-helper1 =
    get-entity-def
    ; ?(x_class, <id>)
    ; filter(generate-java-servlet-hibernate-util-collection-helper2(|x_class))
