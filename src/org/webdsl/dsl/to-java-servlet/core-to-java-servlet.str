module org/webdsl/dsl/to-java-servlet/core-to-java-servlet

imports
  libwebdsl-front
  
imports
  org/webdsl/dsl/to-java-servlet/-
  org/webdsl/dsl/to-java-servlet/types/-
  org/webdsl/dsl/to-java-servlet/uicomponents/-
  org/webdsl/dsl/to-java-servlet/ajax/- 
  org/webdsl/dsl/to-java-servlet/email/-
  org/webdsl/dsl/to-java-servlet/data-validation/-
  org/webdsl/dsl/to-java-servlet/search/-
  org/webdsl/dsl/to-java-servlet/test/-
  org/webdsl/dsl/to-java-servlet/debug/-
  org/webdsl/dsl/to-java-servlet/native/-
  libback-end-transformations

imports		// local generation
  libjava-transformations
  libwrite-files

strategies

  set-DomainPackage(|pkg) = rules( DomainPackage := pkg )
  
  core-to-java-servlet(|qid) =
      prepare-core-to-java-servlet(|qid)
      // generate-code-java-servlet-once should not use the ast, back-end-transformations/analysis for ast analysis
    ; log-time(not(<generate-code-java-servlet-once> None()) |"generate-code-java-servlet-once")
    ; log-time(generate-code-java-servlet      |"generate-code-java-servlet")
    ; transform-java-code
    
  transform-java-code =
    where(  pkgname1 := <TemplatePackage>
          ; pkgname2 := <DomainPackage>
          ; pkgname3 := <ActionPackage>
          ; pkgname4 := <TestPackage>)
  ; <flatten-list>
      [  <log-time(bagof-JavaClassesToEmit; get-java-artifacts-java-servlet | "get-java-artifacts")>
       , <log-time(get-web-xml                    |"get-web-xml")>
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname2 ; public class Force_Domain_Package_Creation {} ]|) 
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname3 ; public class Force_Action_Package_Creation {} ]|)                   
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname4 ; public class Force_Test_Package_Creation {} ]|)                   
      ]
  
  get-web-xml =
    WebXMLToEmit
  
  prepare-core-to-java-servlet(|qid) =
    where(
        rules(
          Package         := <qid-to-package-name> qid        
          TemplatePackage := <qid-to-package-name> Qualified(qid, "templates")
          ActionPackage   := <qid-to-package-name> Qualified(qid, "actions")
          TestPackage     := <qid-to-package-name> Qualified(qid, "test")
          FunctionPackage := <qid-to-package-name> Qualified(qid, "functions")
        )
      ; set-DomainPackage(|<qid-to-package-name> Qualified(qid, "domain")) //strategy/rule shared with seam back-end
    )
    ; annotate-pagecalls
    ; map(try(register-template-name))
    ; is-logging-of-ac-principle-possible
      
  is-logging-of-ac-principle-possible =
    try(oncetd(\e@EntityNoSuper("RequestLogEntry",body) -> e where <oncetd(?Property("principal",_,_,_))> body; rules( ACPrincipalAvailable := True() ) \))

  generate-code-java-servlet =
    ?def@Define(mods, name, args, targs, elems);
      if where(WebDSLCompileBuiltIns) <+ not(has-anno(Precompiled)) then
        {| ThisEmail, JavaThisPage, ThisTemplateName,ThisTemplateClassName, Variables, TemplateFormalArguments, ThisAjaxTemplateName: //Variables: to hold arguments/variables of parent templates/pages
          with (
              if ThisTemplateName   then debug(!"\nERROR: inline local template found in back-end, should have been desugared:\n");<exit> 1 end
            ; if <fetch(Page)>  mods then rules ( JavaThisPage := name ) end
            ; if <fetch(Email)> mods then rules ( ThisEmail := name ) end
            ; if <fetch(AjaxTemplate)> mods then rules ( ThisAjaxTemplateName := name ) end
            ; rules ( 
              ThisTemplateName := name
              ThisTemplateClassName := <get-template-class-name> def
              //TemplateFormalArguments := args
            )
            ; cached-generate(
                  annotate-with-unique-element-ids
                ; log-time(not(GenerateCodeJavaServlet)|"generate code define")
                ; all(generate-code-java-servlet)
                | <ThisTemplateClassName>
              )
          )
       |}
     end
   <+(?Action(_, _, _) <+ ?InitAction(_) <+ ?DataBindAction(_) <+ ?ValidateAction(_) <+ ?RenderAction(_)) ;
         {| InAction, Variables:
           rules ( InAction := True() )
         ; log-time(not(GenerateCodeJavaServlet)|"generate code action")
         ; all(generate-code-java-servlet)
         |}
   <+where(not(JavaInEntity)); ?Function(_,_,_,_); 
      if where(WebDSLCompileBuiltIns) <+ not(has-anno(Precompiled)) then
         generate-java-servlet-global-function
      end
   <+where(get-entity-def => (ent_name, _)) ;
       if where(WebDSLCompileBuiltIns) <+ not(has-anno(Precompiled)) then
         {| JavaInEntity:
           rules ( JavaInEntity := <id> )
         ; cached-generate(
               log-time(not(GenerateCodeJavaServlet)|"generate code entity")
               ; all(generate-code-java-servlet)
             | ent_name
           )
         |}
       end
   <+ ?LocalRedefine(_,_,_,_,_); //avoid page code generation for Arg constructors in LocalRedefine
       {| InLocalRedefine:
           rules ( InLocalRedefine := True() )
         ; log-time(not(GenerateCodeJavaServlet)|"generate code local redefine")
         ; all(generate-code-java-servlet)
         |}
   <+{?el@elem|[ var x : srt := e ]|
         ; where(<elem> (el,<bagof-AllGlobalVars>))}
   <+      log-time(not(GenerateCodeJavaServlet)|"generate code other")
         ; all(generate-code-java-servlet)

// some helping annotations to create uniqueness among the static elements

signature
  constructors
    TemplateCallNumber : String -> Annotation
    FormNumber : String -> Annotation
    InputNumber : String -> Annotation
    ActionNumber : String -> Annotation //action calls/actionLink
    TemplateClassName : String -> Annotation
    RefArgClassNameFirstPart : String -> Annotation
    RefArgClassNameSecondPart : String -> Annotation
   /* ActionClassName : String -> Annotation*/
        
rules

  get-templatecallnumber :
    _{anno*} -> compid
    where TemplateCallNumber(compid) := <collect(?TemplateCallNumber(_));Hd> anno*
 
  get-formnumber :
    _{anno*} -> compid
    where FormNumber(compid) := <collect(?FormNumber(_));Hd> anno* 
    
  get-inputnumber :
    _{anno*} -> compid
    where InputNumber(compid) := <collect(?InputNumber(_));Hd> anno* 
    
  get-actionnumber :
    _{anno*} -> compid
    where ActionNumber(compid) := <collect(?ActionNumber(_));Hd> anno* 
    
  get-refargclassname-first :
    _{anno*} -> compid
    where RefArgClassNameFirstPart(compid) := <collect(?RefArgClassNameFirstPart(_));Hd> anno* 
  get-refargclassname-second :
    _{anno*} -> compid
    where RefArgClassNameSecondPart(compid) := <collect(?RefArgClassNameSecondPart(_));Hd> anno* 
    
  get-template-class-name :
    _{anno*} -> compid
    where TemplateClassName(compid) := <collect(?TemplateClassName(_));Hd> anno* 
 /*
  get-action-class-name :
    _{anno*} -> compid
    where ActionClassName(compid) := <collect(?ActionClassName(_));Hd> anno* 
   */        

strategies

  annotate-pagecalls = 
    alltd(annotate-pagecall)

rules

  annotate-pagecall:
    Define(a,name,b,c,elems){anno*} -> Define(a,name,b,c,elems1){anno*}
    with {| ThisTemplateName: 
           rules(ThisTemplateName := name)
         ; elems1 := <alltd(annotate-pagecall)> elems
         |}

  annotate-pagecall :
    PageCall(pagename,arg*){anno*} -> PageCall(pagename,arg1*){anno*} 
    where not("url" := pagename) //TODO url variant of navigate should have different cons
    with  get-anno(?PageArgsAnno(farg*))
        ; farg1* := <add-farg-numbers> farg*
        ; arg1* := <zip(add-ref-arg-class-names(|pagename)<+?(_,<id>))> (farg1*,arg*)
          
  add-ref-arg-class-names(|pagename) :
    (farg{anno*},arg@FieldAccess(_,_){anno1*}) -> result // not for Var since that would be a template var, which is not available through a page or ajax link
    where <?Arg(_,RefSort(_))> farg
        ; not(<has-ref-type> arg)
    with  <fetch(?ArgNumber(argnum))> anno*
        ; first := <gen-page-ref-arg-class-name-first-part> (pagename,argnum)
        ; second := <gen-page-ref-arg-class-name-second-part>
        ; newid := <concat-strings> [first,second]
        ; rules( RefArgClassName :+= newid)
        ; result := arg{RefArgClassNameFirstPart(first),RefArgClassNameSecondPart(second),anno1*}

  /**
   *  first part, used for all calls to this particular argument of the page
   */ 
  gen-page-ref-arg-class-name-first-part : (pagename,argnum) -> <concat-strings> ["RefArg_",pagename,"_",<int-to-string> argnum,"_"]
          
  /**
   *  second part, added in URL, which selects a particular call site (templatename + (pagecall) number in template) to determine the RefArg class to use
   *  ThisTemplateName is unique, so there is no newname overlap with other templates
   *  since these names are used in a global lookup hashmap, otherwise caches can become invalid
   */
  gen-page-ref-arg-class-name-second-part  = <concat-strings;newname> [<ThisTemplateName>,"pc"]
  
  /**
   *  ajax template calls
   */
  annotate-pagecall = annotate-ajaxcall
  
  annotate-ajaxcall :
    TemplateCall(tname,arg*,a,b){anno*} -> TemplateCall(tname,arg1*,a,b){anno*} 
    where get-anno(?CalledTemplateArgs(farg*))
    with  farg1* := <add-farg-numbers> farg*
        ; arg1* := <zip(add-ref-arg-class-names(|tname)<+?(_,<id>))> (farg1*,arg*)
  
strategies

  annotate-with-unique-element-ids = 
    topdown(try(java-servlet-element-id))
    
rules

  java-servlet-element-id :
    tc@TemplateCall(name, args,passign*, _){anno*} -> tc{TemplateCallNumber(newid),anno*} 
    where <get-anno(?CallToDefinedAnno() <+ ?CallToRequiredAnno())> tc
       <+ <?"elements" <+ ?QualifiedElementsCall(_)> name
    with   newid := <newname> "tcall"
    
  java-servlet-element-id :
    tc@TemplateCall("form", attrs,passign*, elems){anno*} -> tc{FormNumber(newid),anno*} 
    where  newid := <newname> "form"
  
  java-servlet-element-id :
    tc@PropertySubmit(_,_){anno*} -> tc{ActionNumber(newid),anno*} 
    where  newid := <newname> "action"
  java-servlet-element-id-template-call : 
    tc -> tc{InputNumber(newid),anno*} 
    with  _{anno*} := tc
        ; newid := <newname> "input" 
    
  template-class-name-parents: (mod*, allnames) -> class
    with  name := <reverse; separate-by(|"_"); concat-strings> allnames
        ; class := <any-template-name-to-classname> (mod*, name)
    
  register-template-name :
    tc@Define(mod*,x,farg*, targs, elem*){anno*} -> Define(mod*,x,farg*, targs, elem1*){TemplateClassName(className),anno*} 
    with  parentNames := <bigbagof-CurrentHierarchicalName>
        ; className := <template-class-name-parents> (mod*, [x | parentNames])  
        ; {| CurrentHierarchicalName :
              rules( CurrentHierarchicalName :+= x )
            ; elem1* := <alltd(register-template-name)> elem*
          |}
  