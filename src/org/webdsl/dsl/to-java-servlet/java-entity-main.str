 /**

   Generate a JPA/Hibernate entity class from an entity declaration

 */

module org/webdsl/dsl/to-java-servlet/java-entity-main

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/to-java-servlet/core-to-java-servlet
  org/webdsl/dsl/to-java-servlet/search/hibernate-search-annos


signature constructors
  IsGeneratedProperty : Term

overlays

  e_UTILS = expr|[ org.webdsl.tools.Utils ]|

  // both properties are duplicates of org/webdsl/dsl/modules/types/entity, because the overlays in libaries are broken see issue : http://yellowgrass.org/issue/StrategoXT/879
  AllEntityPropertiesCopy =
    [VersionPropertyCopy(), IdPropertyCopy(), NamePropertyCopy(), CreatedPropertyCopy(), ModifiedPropertyCopy()]

  IdPropertyCopy =
    Property("id", Simple(), SimpleSort("UUID"), []){IsGeneratedProperty()}

  VersionPropertyCopy =
    Property("version", Simple(), SimpleSort("Int"), []){IsGeneratedProperty()}

  NamePropertyCopy =
    DerivedProperty("name", Simple(), SimpleSort("String"), [], []){IsGeneratedProperty()}

  CreatedPropertyCopy =
    Property("created", Simple(), SimpleSort("DateTime"){DefValueAnno(exp|[ null ]|)}, []){IsGeneratedProperty()}

  ModifiedPropertyCopy =
    Property("modified", Simple(), SimpleSort("DateTime"){DefValueAnno(exp|[ null ]|)}, []){IsGeneratedProperty()}



strategies

   // @todo factor out code generation for properties to generate @Partial classes

  entity-cbds-equals(|x_Class) = !
    java |[
      public boolean equals(Object o) {
        //return o != null && e_UTILS.isInstance(o, x_Class.class) && e_UTILS.equal(((x_Class)o).getId(), getId());
        return o != null
          && o instanceof org.webdsl.WebDSLEntity
          && ((org.webdsl.WebDSLEntity) o).instanceOf("~x_Class")
          && e_UTILS.equal(((o instanceof org.hibernate.proxy.HibernateProxy)?
               x_Class.class.cast( ((org.hibernate.proxy.HibernateProxy) o).getHibernateLazyInitializer().getImplementation())
             : x_Class.class.cast(o)).getId(), getId());
      }
    ]|

   entity-to-java-entity :
     ent@EntityNoSuper(x_Class, entbodydecs){anno*} ->
     <emit-java-code-local> compilation-unit|[
       package pkgname;

       @javax.persistence.Entity
       mod0*
       mod1*
       mod2*
       mod3
       mod4*
       mod5*
       mod6
       //@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
       @org.hibernate.annotations.Persister(impl = utils.SingleTableEntityPersister.class)
       @javax.persistence.DiscriminatorColumn(name = "DISCRIMINATOR", discriminatorType = javax.persistence.DiscriminatorType.STRING, length = 255)
       public class x_Class implements org.webdsl.WebDSLEntity, org.hibernate.bytecode.javassist.FieldHandled, tname_1
       {
          public x_Class () {}

          transient protected org.hibernate.bytecode.javassist.FieldHandler fieldHandler;
          transient protected java.util.Set<String> uninitializedLazyProperties = null;

          public org.hibernate.bytecode.javassist.FieldHandler getFieldHandler() {
            return fieldHandler;
          }

          public boolean removeUninitializedLazyProperty(String name) {
            return uninitializedLazyProperties != null && uninitializedLazyProperties.remove(name);
          }

          public void setFieldHandler(org.hibernate.bytecode.javassist.FieldHandler fieldHandler) {
            this.fieldHandler = fieldHandler;
            java.util.Set fieldHandlerUninit = ((org.hibernate.intercept.javassist.FieldInterceptorImpl)fieldHandler).getUninitializedFields();
            if(fieldHandlerUninit != null) {
              this.uninitializedLazyProperties = new java.util.HashSet<String>(fieldHandlerUninit); // We need a new instance, because the set is static
            }
          }

          ~*idcodes
          ~*<version-property>[]
          ~*<is-changed-property( fail | x_Class)> []
          ~*<is-request-var-property>[]

          ~*[<entity-cbds-equals(|x_Class)>]

          public int hashCode() {
            if (getId() == null)
              return super.hashCode();
            else
              return getId().hashCode();
          }

          public int compareTo(org.webdsl.WebDSLEntity o) {
            return getId().compareTo(((x_Class)o).getId());
          }

          public boolean isInstance(Class<?> c) {
            return c.isInstance(this);
          }

          public boolean instanceOf(String s){
            return s.equals("~x_Class")||s.equals("Object")||s.equals("Entity");
          }

          ~*cbds

          public String get_WebDslEntityType(){
            return "~x_Class";
          }
       }
     ]|
     with
        idcodes := <hibernate-default-id-prop(|x_Class)> ent
      ; props := <filter(is-property-cons)> entbodydecs
      ; props_with_extras := [CreatedPropertyCopy(), ModifiedPropertyCopy() | props]
      ; cbds := <properties-to-code(|x_Class,ent)> props_with_extras
      ; pkgname := <DomainPackage>
      ; mod0* := <table-mapping-annos> (ent, x_Class)
      ; if <get-anno(?IndexedAnno(_,_,_,_,_,_,_))> ent then
          mod1* := [anno|[ @org.hibernate.search.annotations.Indexed ]|]
        else
          mod1* := []
        end
      ; if<get-anno(?HasDynamicSearchFields())> ent then
          mod6 := [anno|[ @org.hibernate.search.annotations.ClassBridge( impl = org.webdsl.search.WebDSLDynamicFieldBridge.class ) ]|]
        ; tname_1 := TypeName(Id("org.webdsl.search.DynamicSearchFields"))
        else
          mod6 := []
        ; tname_1 := TypeName(Id("org.webdsl.search.NoDynamicSearchFields")) //java-front has no tname*, so use dummy interface instead of [] for now
        end
      ; if<get-anno(?AnalyzersInUseAnno( (analyzers, _) ))> ent then
          mod2* := <do-once(define-fts-filters-anno | "define-fts-filters-anno")<+![]> []
         ;mod3  := <map(define-fulltext-analyzer-anno); flatten-list; wrap-in-analyzer-defs-anno <+![]> analyzers
        else
          mod2* := []
         ;mod3  := []
        end
         ; if <get-anno(?CachedEntity())> ent then
          mod4* := [anno |[ @org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE) ]|]
        else
          mod4* := []
        end
      ; mod5* := <query-condition-filterdef-annotations <+ ![]> anno*

   entity-to-java-entity :
     sent@SessionEntity(x_ident, entbodydecs) ->
     <emit-java-code-local> compilation-unit|[
       package pkgname;

       @Entity
       mod0*
       mod1*
       public class x_Class implements org.webdsl.WebDSLEntity, org.hibernate.bytecode.javassist.FieldHandled
       {
        public x_Class () {}

        transient protected org.hibernate.bytecode.javassist.FieldHandler fieldHandler;
        transient protected java.util.Set<String> uninitializedLazyProperties = null;

        public org.hibernate.bytecode.javassist.FieldHandler getFieldHandler() {
          return fieldHandler;
        }

        public boolean removeUninitializedLazyProperty(String name) {
          return uninitializedLazyProperties != null && uninitializedLazyProperties.remove(name);
        }

        public void setFieldHandler(org.hibernate.bytecode.javassist.FieldHandler fieldHandler) {
          this.fieldHandler = fieldHandler;
          java.util.Set fieldHandlerUninit = ((org.hibernate.intercept.javassist.FieldInterceptorImpl)fieldHandler).getUninitializedFields();
          if(fieldHandlerUninit != null) {
            this.uninitializedLazyProperties = new java.util.HashSet<String>(fieldHandlerUninit); // We need a new instance, because the set is static
          }
        }

        ~*<hibernate-default-id-prop(|x_Class)>[]
        ~*<version-property-session-entity>[]
        ~*<is-changed-property( id | x_Class)> []
        ~*<is-request-var-property>[]

        ~*[<entity-cbds-equals(|x_Class)>]

        public int hashCode() {
          if (getId() == null)
            return super.hashCode();
          else
            return getId().hashCode();
        }

        public int compareTo(org.webdsl.WebDSLEntity o) {
          return getId().compareTo(((x_Class)o).getId());
        }

        public boolean isInstance(Class<?> c) {
          return c.isInstance(this);
        }

        public boolean instanceOf(String s){
          return s.equals("~x_Class")||s.equals("Object")||s.equals("Entity");
        }

        ~*cbds
        ~*cbds1

        public String get_WebDslEntityType(){
          return "~x_Class";
        }

       }
     ]|
     with x_Class := <capitalize-string> x_ident
        ; props := <filter(is-property-cons)> entbodydecs
        ; props_with_extras := [CreatedPropertyCopy(), ModifiedPropertyCopy() | props]
        ; cbds := <properties-to-code(|x_Class,sent)> props_with_extras
        ; cbds1 := <filter(property-to-session-prop-ids(|x_Class));try(concat)> props
        ; pkgname := <DomainPackage>
        ; mod0* := <table-mapping-annos> (sent, x_Class)
        ; if <get-anno(?CachedEntity())> sent then
            mod1* := [anno |[ @org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE) ]|]
          else
            mod1* := []
          end

   entity-to-java-entity :
     ent@Entity(x_Class, x_super, entbodydecs){anno*} ->
     <emit-java-code-local> compilation-unit|[
       package pkgname;

       @javax.persistence.Entity
       mod1*
       mod2*
       mod3*
       public class x_Class extends x_super implements org.webdsl.WebDSLEntity, org.hibernate.bytecode.javassist.FieldHandled, tname_1
       {
         public x_Class () {
           instanceOfTypes#x_Class.add("~x_Class");
           bstm*
         }

         ~*[<entity-cbds-equals(|x_Class)>]

         public int hashCode() {
           if (getId() == null)
             return super.hashCode();
           else
             return getId().hashCode();
         }

         public int compareTo(org.webdsl.WebDSLEntity o) {
           return getId().compareTo(((x_Class)o).getId());
         }

         public boolean isInstance(Class<?> c) {
           return c.isInstance(this);
         }

         //@org.hibernate.annotations.CollectionOfElements
         @Transient
         java.util.List<String> instanceOfTypes#x_Class = new java.util.LinkedList<String>();

         public boolean instanceOf(String s){
           return instanceOfTypes#x_Class.contains(s);
         }

         ~*cbds

         public String get_WebDslEntityType(){
           return "~x_Class";
         }
       }
     ]|
     with  props := <filter(is-property-cons)> entbodydecs
         ; cbds := <properties-to-code(|x_Class, ent)> props
         ; pkgname := <DomainPackage>
         ; superclasses := <get-anno(?SuperClassesAnno(<id>))> ent
         ; bstm* := <map(\super -> bstm|[ instanceOfTypes#x_Class.add("~super"); ]| \)> superclasses
         ; if <get-anno(?IndexedAnno(_,_,_,_,_,_,_))> ent then
             mod1* := [anno|[ @org.hibernate.search.annotations.Indexed ]|]
           else
             mod1* := []
           end
         ; if<get-anno(?HasDynamicSearchFields())> ent then
             mod3* := [anno|[ @org.hibernate.search.annotations.ClassBridge( impl = org.webdsl.search.WebDSLDynamicFieldBridge.class ) ]|]
           ; tname_1 := TypeName(Id("org.webdsl.search.DynamicSearchFields"))
           else
             mod3* := []
           ; tname_1 := TypeName(Id("org.webdsl.search.NoDynamicSearchFields")) //java-front has no tname*, so use dummy interface instead of [] for now
           end
         ; mod2* := <query-condition-filterdef-annotations <+ ![]> anno*
      // @note: don't define id on an entity with a super class; it
      // is inherited from the super class

  entity-to-class-fails =
     (?EntityNoSuper(_, _) <+ ?Entity(_,_,_))
     ; err(|"cannot generate code for entity")

 strategies

   name-property :
     x_prop -> class-body-dec* |[
       public String getName() {
         if(x_get()!=null)
         {
           return x_get().toString();
         }
         else
         {
           return "";
         }
       }
     ]|
     where x_get := <concat-strings>["get", <capitalize-string> x_prop]

 define-fts-filters-anno = ![anno|[ @org.hibernate.search.annotations.FullTextFilterDefs({
                                      @org.hibernate.search.annotations.FullTextFilterDef(name = "fieldConstraintFilter0", impl = org.webdsl.search.FieldConstraintFilter.class)
                                    , @org.hibernate.search.annotations.FullTextFilterDef(name = "fieldConstraintFilter1", impl = org.webdsl.search.FieldConstraintFilter.class)
                                    , @org.hibernate.search.annotations.FullTextFilterDef(name = "fieldConstraintFilter2", impl = org.webdsl.search.FieldConstraintFilter.class)
                                    , @org.hibernate.search.annotations.FullTextFilterDef(name = "fieldConstraintFilter3", impl = org.webdsl.search.FieldConstraintFilter.class)
                                    , @org.hibernate.search.annotations.FullTextFilterDef(name = "fieldConstraintFilter4", impl = org.webdsl.search.FieldConstraintFilter.class)
                                    , @org.hibernate.search.annotations.FullTextFilterDef(name = "namespaceConstraintFilter" , impl = org.webdsl.search.NamespaceConstraintFilter.class)
                                    })
                            ]|]

  version-property = version-property(| java:expr|[ 0 ]|)

  version-property-session-entity = version-property(| java:expr|[ 1 ]|) // session variables are always persisted

  version-property(| e_default)=
    !class-body-dec* |[
      @Version
      @Column(name="version_opt_lock")
      protected Integer _version = e_default; //set to 0 to prevent queries from flushing
      public Integer getVersion() {
        return _version;
      }
      public void setVersion(Integer v) {
        this._version = v;
        setChanged(); // call after setting version, because it checks whether version > 0 to recognize persisted objects
      }
      @Transient boolean versionWasIncreased = false;
      public void increaseVersion(){
        if(!versionWasIncreased){
          _version++;
          versionWasIncreased = true;
          setChanged();
        }
      }
    ]|

  is-changed-property( if-session-ent | x_Class)=
    where( pkgtname_domain := <DomainPackage>)
  ; !class-body-dec* |[
      @Transient
      protected boolean isChanged = false;
      public boolean isChanged(){return isChanged;}
      public void setChanged(){
        if(!isChanged){
          isChanged = true;
          if(fieldHandler != null){ ((org.hibernate.intercept.FieldInterceptor)fieldHandler).dirty(); }
        }
        AbstractPageServlet thepage = ThreadLocalPage.get();
        // If this entity is marked as saved (version > 0) then there will be writes, thus enable flush mode.
        // This also covers cascaded save (transient entity saved by being referred from other persisted entity),
        // because adding the transient entity will call the setChanged on the side of the persisted entity
        // which detects that there will be writes.
        if(_version > 0){
          if(thepage != null){ thepage.readOnlyRequestStats = false; }
          // purge page cache unless this is an internal bookkeeping entity
          ~*<if <?"SessionManager" <+ ?"SessionMessage" <+ ?"QueuedEmail"> x_Class then ![] end> bstm*|[
            ~*<if if-session-ent then !bstm*|[ // if session entity changed, only clear user-specific page cache
              if(thepage != null && !thepage.invalidateUserSpecificPageCache && !thepage.invalidateAllPageCache){
                ((pkgtname_domain.SessionManager)ThreadLocalServlet.get().getSessionManager()).setSessionHasChangesNoEventsOrValidation(true); // if any session entities are touched, switch to user-specific page cache
                thepage.invalidateUserSpecificPageCache("~x_Class");
              }
            ]|
            else !bstm*|[ // application entity changed, clear all page caches
              if(thepage != null && !thepage.invalidateAllPageCache){
                thepage.invalidateAllPageCache("~x_Class");
              }
            ]|
            end> []
          ]|
          if(thepage != null && thepage.isReadOnly){ // page has read-only modifier but apparently there is an attempt to edit, log warning
            org.webdsl.logging.Logger.warn("page or ajax template is forced to be read-only, but a persisted entity property is attempted to be updated in "+"~x_Class");
            utils.Warning.printSmallStackTrace(5);
          }
          else{
            // always set flush mode back to AUTO here, this is required for the manual flush control optimization, see FastAutoFlushEventListener in java-runtime/src/utils/HibernateUtil.java
            // after a flush the commit mode is set to COMMIT instead of AUTO to avoid unnecessary flushes, if there is a real entity data change, it needs to be set back to AUTO here
            e_HibSession.setFlushMode(org.hibernate.FlushMode.AUTO);
          }
        }
      }
    ]|


  is-request-var-property =
    !class-body-dec* |[
      @Transient
      protected boolean isRequestVar = false;
      public boolean isRequestVar(){return isRequestVar;}
      public void setRequestVar(){
        isRequestVar = true;
      }
    ]|

  table-mapping-annos :
    (ent, x_class) -> result
    where x_tablename := <concat-strings> ["_",x_class]
        ; /*
           * uniqueness constraint removed, to cope with auto flush behavior and validation rule using query to check uniqueness
           * this situation causes a failure due to the uniqueness constraint triggering while validating
           */
          /*if x_name := <get-type-anno;has-natural-id;get-entity-id-name> ent
          then //java-mix needs more fine-grained elements for annotations
            x_propunique := <concat-strings> ["\\\"_",x_name,"\\\""]
          ; result := [anno |[
              @javax.persistence.Table(
                name="~x_tablename",
                uniqueConstraints=@UniqueConstraint(columnNames={"~x_propunique"})
              )
            ]|]
          else*/
            result := [anno |[
              @javax.persistence.Table(
                name="~x_tablename"
              )
            ]|]
          //end

  hibernate-default-id-prop(|x_class) =
    ?ent;
    where(
        mod0* := [anno|[ @org.hibernate.search.annotations.DocumentId ]|,
                  anno|[ @org.hibernate.search.annotations.FieldBridge(impl=UUIDFieldBridge.class) ]|]
    )
    ; !class-body-dec* |[

      //not using native id generator of dbms, because this can cause flushes when executing queries with transient entities in the where-clause
      @javax.persistence.Id
      @org.hibernate.annotations.Type(type = "utils.UUIDUserType")
      mod0*
      @javax.persistence.Column(name="id",length=32) //mysql adds 1 byte prefix for length internally http://dev.mysql.com/doc/refman/5.0/en/char.html
      protected java.util.UUID _id = null;

      public java.util.UUID getId() { return _id; }

      public void setId(java.util.UUID idarg) { this._id = idarg; }

      ~*<where("id":=<get-type-anno;get-entity-id-name> ent)<+![]> class-body-dec* |[
        public String getNaturalId() { return _id.toString(); }
        //public static boolean hasNaturalId() { return false; }
      ]|
    ]|

   properties-to-code(|x_Class,entity) :
     props -> cbds
     where x_idname := <get-type-anno; get-entity-id-name> entity
         ; cbds1 := <filter-concat-warn(property-to-property-code(|x_Class,x_idname)
                                        | "cannot generate code for property: ")> props
         ; cbds2 := <get-anno(?NamePropertyAnno(<id>)); name-property <+ ![]> entity
         ; cbds  := <concat>[cbds1, cbds2]

 rules

   /**
    * Property is a protected field with a getter and a setter.
    */

   property-to-property-code(|x_Class,id_name) :
     prop@Property(x, k, s, annos) -> class-body-dec* |[

       mod1* mod2* mod3* mod4* mod5* mod6* mod7* protected t _#x = e;

       public t get#x() {
         bstm_lazygetter*
         return _#x;
       }

       public boolean is#x#Uninitialized() {
         bstm_lazyinit*
       }

       ~*<where(not(GenericSort(_,_) := s)) <+ ![]> class-body-dec* |[ //setter for non-collections
         public void set#x(t newitem) {
           if(!x#BeingSet) {
             x#BeingSet = true;
             setChanged();
             ~*bas*
             bstm_setterextension*
             bstm_lazysetter*
             x#BeingSet = false;
           }
         }
         // used by eg. unique id functions
         public void set#x#NoEventsOrValidation(t newitem) {
           setChanged();
           bstm_lazysetter*
         }
       ]|
       ~*<where(GenericSort(_,_) := s) <+ ![]> class-body-dec* |[ //assignment for collections is rewritten to clear();addall(x);
         public void set#x(t newitem) {
           setChanged();
           _#x = newitem;
         }
       ]|

       @Transient boolean x#BeingSet = false;

       ~*cbd*
       ~*cbds_naturalid

     ]|
    where t      := <java-type> s
        ; e      := <owned-collection-default-value-override-java(|x_Class,prop) <+ java-type-default-value> s
        ; if <!id_name;?x> x_Class     // if this is the id property
          then
              x_index := <newname> <concat-strings>[x,"index"]
            //; mod0* := [anno|[@org.hibernate.annotations.Index(name="~x_index")]|]  unique annotation(in table annotation) already creates index
            ; cbds_naturalid := class-body-dec* |[
               public String getNaturalId() {
                 return _#x.toString(); //utils.URLFilter.filter(_#x.toString()); //custom encoding of problematic characters in URLs
               }
               //public static boolean hasNaturalId() { return true; }
             ]|
             ; <gen-unique-function-for-id-prop> (x_Class,x,s)
          else cbds_naturalid:=[] end
        ; mod1*  := <persistence-annotations> s
        ; mod2*  := <property-to-persistence-annotations(|x_Class)> prop
        ; mod3*  := <field-access-for-simple-sorts <+ ![]> prop
        ; mod4*  := <type-specific-annotations <+ ![]> prop  // optional, can be used to specify annotations for specific file, eg see to-java-servlet/types/file.str
        ; cbd*   := <property-to-special-getters(|x_Class) <+ ![]> prop
        ; bas*     := <inverse-mutation-in-setter(|x) <+ ![]> prop
    with  bstm_setterextension* := <entity-bstm-property-events> (x_Class,x,s,"set","newitem")
        ; mod5*   := <property-to-contained-in <+ ![]> prop
        ; mod6*  := <property-to-index-annos <+ ![]> prop
        ; mod7*  := <fetch-elem(\ SimpleAnno("cache") -> [anno |[ @org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE) ]|] \) <+ ![]> annos
        ; (bstm_lazygetter*, bstm_lazysetter*, bstm_lazyinit*) := <handle-lazy-one-to-one-inverse(|x, annos) <+ !([], bstm*|[ t olditem = _#x; _#x = newitem; ]|, <property-to-isuninitialized> prop)> s

   handle-lazy-one-to-one-inverse(|x, annos) :
     s@SimpleSort(y) -> ( bstm* |[ if (fieldHandler != null && uninitializedLazyProperties != null && uninitializedLazyProperties.contains("~str")) {
                                     uninitializedLazyProperties.remove("~str");
                                     return (y) e_UTILS.readLazyProperty(this, fieldHandler, "~str", _#x);
                                   }
                                ]|,
                          bstm* |[ t olditem = _#x;
                                   if(fieldHandler != null) {
                                     olditem = (y)fieldHandler.readObject(this, "~str", _#x); // Initializes all lazy properties
                                     uninitializedLazyProperties = null;
                                   }
                                   _#x = newitem; // We do not need a writeObject here, because we already did a readObject and we set the dirty flag in setChanged
                                ]|,
                          bstm* |[ return fieldHandler != null && uninitializedLazyProperties != null && uninitializedLazyProperties.contains("~str") && !utils.QueryOptimization.uniqueKeyInContext(this, fieldHandler, "~str"); ]|
                        )
     where t := <java-type> s
         ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld))> annos
         ; SimpleSort(yy) := <get-type-anno> inv
         ; str := <concat-strings>["_", x]

  property-to-isuninitialized:
    Property(x, k, SimpleSort(_), _) -> bstm* |[ return _#x instanceof org.hibernate.proxy.HibernateProxy && ((org.hibernate.proxy.HibernateProxy)_#x).getHibernateLazyInitializer().isUninitialized(); ]|
    where <?Ref() <+ ?Comp()> k

  property-to-isuninitialized:
    Property(x, k, GenericSort(_,_), _) -> bstm* |[ return _#x instanceof org.hibernate.collection.PersistentCollection && !((org.hibernate.collection.PersistentCollection)_#x).wasInitialized(); ]|
    where <?Ref() <+ ?Comp()> k

  property-to-isuninitialized:
    Property(_, Simple(), _, _) -> bstm* |[ return false; ]|

   field-access-for-simple-sorts:
     prop@Property(x_prop, k, SimpleSort(y), annos) -> [anno|[ @org.hibernate.annotations.AccessType(value="field") ]|]

   property-to-property-code(|x_Class, idname):
     prop@DerivedProperty(x, k, s, annos, e) -> class-body-dec* |[

       mod* public t get#x() {
         return ~e:gettercode;
       }

       ~*cbd*
     ]|
     where t      := <java-type> s
         ; gettercode := <expression-to-java-servlet> e
         ; cbd*   := <property-to-special-getters(|x_Class) <+ ![]> prop
         ; mod*  := <property-to-index-annos <+ ![]> prop

rules // special session entity props

   property-to-session-prop-ids(|x_Class) :
     prop@Property(x, k, s, annos) -> class-body-dec* |[

       @Transient
       protected java.util.UUID x#ident = null;

       public java.util.UUID get#x#ident() {
         return x#ident;
       }

       public void set#x#ident(java.util.UUID newitem) {
         x#ident = newitem;
       }

     ]|
     where t := <defined-java-type> s // only succeeds for entity refs

rules // annotations for properties

  property-to-persistence-annotations(|x_Class) :
  Property(x_prop, k, s, annos){anno*} -> result
  with  if <fetch(?SimpleAnno("transient"))> annos
        then result := [ anno|[ @javax.persistence.Transient ]| ] // marks a property as transient, will not be persisted to the database
        else association-annos := <association-annotations(|x_Class, x_prop, annos)> s
           ; cascade-annos := <cascade-annotations> k
           ; column-annos := <column-annotations(|x_prop,s,annos)>
           ; filter-annos := <query-condition-filter-annotations <+ ![]> anno*
           ; result := <concat> [association-annos, cascade-annos, column-annos, filter-annos]
        end

  query-condition-filter-annotations :
    anno* -> [anno]
    where <fetch-elem(?QueryConditionFilterDefs(fltrs))> anno*
    ; [fltr] := fltrs // Only one filter
    ; anno := <query-condition-filter-annotation> fltr

  query-condition-filter-annotations :
    anno* -> [anno |[ @org.hibernate.annotations.Filters({~annos*}) ]|]
    where <fetch-elem(?QueryConditionFilterDefs(fltrs))> anno*
    ; not([] := fltrs; [_] := fltrs) // At least two filters
    ; annos* := <map(query-condition-filter-annotation)> fltrs

  query-condition-filter-annotation :
    QueryConditionFilterDef(name, types, cond, _) -> anno |[ @org.hibernate.annotations.Filter(name="~name") ]|

  query-condition-filterdef-annotations :
    anno* -> [anno]
    where <fetch-elem(?QueryConditionFilterDefs(fltrs))> anno*
    ; [fltr] := fltrs // Only one filter
    ; anno := <query-condition-filterdef-annotation> fltr

  query-condition-filterdef-annotations :
    anno* -> [anno |[ @org.hibernate.annotations.FilterDefs({~annos*}) ]|]
    where <fetch-elem(?QueryConditionFilterDefs(fltrs))> anno*
    ; not([] := fltrs; [_] := fltrs) // At least two filters
    ; annos* := <map(query-condition-filterdef-annotation)> fltrs

  query-condition-filterdef-annotation :
    QueryConditionFilterDef(name, types, strCond, _) -> anno |[ @org.hibernate.annotations.FilterDef(name="~name", defaultCondition="~strCond", parameters = {~params*}) ]|
    with params* := <zip; map(filter-param-to-anno)> (<length; range> types, types)

  filter-param-to-anno :
    (i, srt) -> anno |[ @org.hibernate.annotations.ParamDef( name="~name", type="~type" ) ]|
    with name := <concat-strings> [ "param", <int-to-string> i ]
    ; type := <simple-sort-to-hibernate-type-string> srt

  simple-sort-to-hibernate-type-string : SimpleSort("Int") -> "integer"
  simple-sort-to-hibernate-type-string : SimpleSort("Long") -> "long"
  simple-sort-to-hibernate-type-string : SimpleSort("Bool") -> "boolean"
  simple-sort-to-hibernate-type-string : SimpleSort("Float") -> "float"
  simple-sort-to-hibernate-type-string : SimpleSort("String") -> "string"

rules

  // add explicit column name annotation with quotes to work around hibernate issue with join queries:
  // http://opensource.atlassian.com/projects/hibernate/browse/HHH-5086
  // http://opensource.atlassian.com/projects/hibernate/browse/HHH-4891
  column-annotations(|x_prop,s,annos) :
    _ -> result
    where not(<fetch(?InverseSlaveAnno(_, _) <+ ?InverseAnno(_, _))> annos)
    where not(<?GenericSort(_,_)> s)
    where not(<has-entity-anno> s)
    where not(<?SimpleSort("File") <+ ?SimpleSort("Image") <+ ?SimpleSort("UUID")> s)
    with  x_anno := <concat-strings> ["\\\"_",x_prop,"\\\""]
        ; if   <not(fetch(?LengthAnno(_)))> annos
          then result := [anno|[ @javax.persistence.Column(name = "~x_anno") ]|]
          else <fetch(?LengthAnno(x_length))> annos
             ; result := [anno|[ @javax.persistence.Column(name = "~x_anno", length = x_length) ]|]
          end

  column-annotations(|x_prop,s,annos) :
    _ -> [anno |[ @org.hibernate.annotations.Type(type = "utils.UUIDUserType") ]|
        , anno|[ @javax.persistence.Column(name = "~x_anno", length = 32) ]|] //mysql adds 1 byte prefix for length internally http://dev.mysql.com/doc/refman/5.0/en/char.html
    where SimpleSort("UUID") := s
        ; x_anno := <concat-strings> ["\\\"_",x_prop,"\\\""]

  column-annotations(|x_prop,s,annos) :
    _ -> []  // no column anno when there is an inverse, or the property is a collection, or the property is an entity reference
    where <fetch(?InverseSlaveAnno(_, _) <+ ?InverseAnno(_, _))> annos
       <+ <?GenericSort(_,_)> s
       <+ <has-entity-anno> s
       <+ <?SimpleSort("File") <+ ?SimpleSort("Image")> s

rules // Property with a value type

  association-annotations(|x_Class, x_prop, annos) :
    s@SimpleSort(y) -> []
    where <builtin-java-type> s

rules // Property with a reference or composite association type

  association-annotations(|x_class, x_prop, annos) :
    s@SimpleSort(y) ->
    [
      anno|[ @ManyToOne(fetch=javax.persistence.FetchType.LAZY) ]|,
      anno|[ @JoinColumn(name = "~columnname") ]|
    ]
    where [] := <collect(?InverseSlaveAnno(_, _) <+ ?InverseAnno(_, _))> annos
        ; t          := <defined-java-type> s
    with  x_Prop     := <capitalize-string> x_prop
        ; columnname := <concat-strings>["\\\"", x_class, "_", x_prop, "\\\""]

rules // set or list of defined entity without inverse

  association-annotations(|x_class, x_prop, annos) :
    GenericSort(coll, [s@SimpleSort(ss)]) -> [
      anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|
    , anno|[ @JoinTable( name="~tableName" ) ]|
    , anno|[ @org.hibernate.annotations.Persister(impl = utils.BasicCollectionPersister.class) ]|
    | [subselect*, anno-list*]
    ]
    where <?"Set" <+ ?"List"> coll
        ; t := <defined-java-type> s
        ; [] := <collect(?InverseSlaveAnno(_, _) <+ ?InverseAnno(_, _))> annos
        ; indexname := <concat-strings> ["\\\"", x_class, x_prop,"index\\\""]
        ; anno-list* := <?"List"; ![anno |[ @org.hibernate.annotations.IndexColumn(name = "~indexname", base=0) ]|] <+ ![]> coll
        ; tableName   := <concat-strings> [x_class, "_", x_prop, "_", ss]
        ; subselect* := <get-subselect-anno>

rules //one-to-one
// In this case the owning side is determined by the annotation.

   // bidirectional one-to-one controlling side
   association-annotations(|x_class, x_prop, annos) :
     s@SimpleSort(y) ->
     [
       anno|[ @OneToOne(fetch=javax.persistence.FetchType.LAZY) ]|,
       anno|[ @JoinColumn(name="~x_fk") ]|
     ]
     where t := <defined-java-type> s
         ; inv := <fetch-elem(?InverseAnno(ent, fld))> annos
         ; SimpleSort(yy)                := <get-type-anno> inv
         ; x_fk                          := <concat-strings> ["\\\"", x_class, "_", x_prop, "\\\""]

   // bidirectional one-to-one inverse side
   association-annotations(|x_class, x_prop, annos) :
     s@SimpleSort(y) ->
     [
       anno|[ @OneToOne(mappedBy="~mappedby",fetch=javax.persistence.FetchType.LAZY) ]|,
       anno|[ @org.hibernate.annotations.LazyToOne(org.hibernate.annotations.LazyToOneOption.NO_PROXY) ]|
     ]
     where t := <defined-java-type> s
         ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld))> annos
         ; SimpleSort(yy) := <get-type-anno> inv
         ; mappedby       := <concat-strings> ["_", fld]

rules // One-to-Many association with Set

  get-subselect-anno = is-hibernate-subselect < ![anno|[ @org.hibernate.annotations.Fetch(value = org.hibernate.annotations.FetchMode.SUBSELECT) ]|] + ![]

  // bidirectional many-to-one owning side Ref-Set
  association-annotations(|x_class, x_prop, annos) :
    s@SimpleSort(y) ->
    [
      anno|[ @ManyToOne(fetch=javax.persistence.FetchType.LAZY) ]|
    , anno|[ @JoinColumn(name="~joinColumnName") ]|
    ]
    where t := <defined-java-type> s
        ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld) <+ ?InverseAnno(ent, fld))> annos
        ; GenericSort("Set", [SimpleSort(yy)]) := <get-type-anno> inv
        ; joinColumnName := <concat-strings> ["\\\"", x_class, "_", x_prop, "\\\""]

  // bidirectional one-to-many inverse side Set-Ref
  association-annotations(|x_class, x_prop, annos) :
    GenericSort("Set", [s]) -> [
      anno|[ @OneToMany(fetch=javax.persistence.FetchType.LAZY) ]| //mappedBy="~other_prop", targetEntity=x_ent,
    , anno|[ @JoinColumn(name="~joinColumnName", insertable=false, updatable=false) ]|
    , anno|[ @org.hibernate.annotations.Persister(impl = utils.OneToManyPersister.class) ]|
    | subselect*
    ]
    where t := <defined-java-type> s
        ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld) <+ ?InverseAnno(ent, fld))> annos
        ; SimpleSort(ident) := <get-type-anno> inv
        //; other_prop := <concat-strings>["_", fld]
        //; x_ent := <concat-strings> [ent, ".class"]
        ; joinColumnName := <concat-strings> ["\\\"", ent, "_", fld, "\\\""]
        ; subselect* := <get-subselect-anno>

rules // One-to-Many association with List: not true inverse (duplication in db) due to hibernate limitations

  // bidirectional many-to-one inverse side Ref-List
  association-annotations(|x_class, x_prop, annos) :
    s@SimpleSort(y) -> [
      anno|[ @ManyToOne(fetch=javax.persistence.FetchType.LAZY) ]|
    , anno|[ @JoinColumn(name = "~joinColumnNameOneSide") ]|
    ]
    where t := <defined-java-type> s
        ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld) <+ ?InverseAnno(ent, fld))> annos
        ; GenericSort("List", [SimpleSort(yy)]) := <get-type-anno> inv
        ; joinColumnNameOneSide := <concat-strings> ["\\\"", x_class, "_", x_prop, "\\\""] //[ent, "_", fld, "_one_side"]

  // bidirectional one-to-many owning side List-Ref
  association-annotations(|x_class, x_prop, annos) :
    GenericSort("List", [s@SimpleSort(ss)]) -> [
      anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|
    , anno|[ @JoinTable( name="~tableName",
                         joinColumns={@JoinColumn(name="~thisid")},
                         inverseJoinColumns={@JoinColumn(name="~otherid")} ) ]|
    , anno|[ @org.hibernate.annotations.IndexColumn(name = "~indexname", base=0) ]|
    , anno|[ @org.hibernate.annotations.Persister(impl = utils.BasicCollectionPersister.class) ]|
    | subselect*
    ]
    where t := <defined-java-type> s
        ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld) <+ ?InverseAnno(ent, fld))> annos
        ; SimpleSort(ident) := <get-type-anno> inv
        ; indexname := <concat-strings> ["\\\"", x_class, x_prop,"index\\\""]
        ; tableName := <concat-strings> [x_class, "_", x_prop, "_", ss]
        ; thisid    := <concat-strings> ["\\\"", x_class, "_id_owner", "\\\""]
        ; otherid   := <concat-strings> ["\\\"", ent, "_id_inverse", "\\\""]
        ; subselect* := <get-subselect-anno>

rules   // Many-to-Many associations Set-Set
// In this case the owning side is determined by the annotation.

   // bidirectional many-to-many controlling side
   association-annotations(|x_class, x_prop, annos) :
      GenericSort("Set", [s@SimpleSort(ss)]) ->
      [
        anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|,
        anno|[ @JoinTable( name="~tableName",
                           joinColumns={@JoinColumn(name="~thisid")},
                           inverseJoinColumns={@JoinColumn(name="~otherid")} ) ]|
        , anno|[ @org.hibernate.annotations.Persister(impl = utils.BasicCollectionPersister.class) ]|
        | subselect*
      ]
    where t := <defined-java-type> s
        ; inv := <fetch-elem(?InverseAnno(ent, fld))> annos
        ; GenericSort("Set", [SimpleSort(yy)]) := <get-type-anno> inv
        ; tableName := <concat-strings> [x_class, "_", x_prop, "_", ss]
        ; thisid    := <concat-strings> ["\\\"", x_class, "_id_owner\\\""]
        ; otherid   := <concat-strings> ["\\\"", ent, "_id_inverse\\\""]
        ; subselect* := <get-subselect-anno>

   // bidirectional many-to-many inverse side
   association-annotations(|x_class, x_prop, annos) :
     GenericSort("Set", [s@SimpleSort(ss)]) ->
       [
         anno|[ @ManyToMany( mappedBy="~mappedby", targetEntity=x_ent ,fetch=javax.persistence.FetchType.LAZY) ]|
         , anno|[ @org.hibernate.annotations.Persister(impl = utils.BasicCollectionPersister.class) ]|
         | subselect*
       ]
     where t := <defined-java-type> s
         ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld))> annos
         ; GenericSort("Set", [SimpleSort(yy)]) := <get-type-anno> inv
         ; x_ent                            := <concat-strings> [ent, ".class"]
         ; mappedby                         := <concat-strings> ["_", fld]
         ; subselect* := <get-subselect-anno>

rules   // Many-to-Many associations List-Set

   // bidirectional many-to-many controlling side
   association-annotations(|x_class, x_prop, annos) :
      GenericSort("List", [s@SimpleSort(ss)]) ->
      [
        anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|
      , anno|[ @JoinTable( name="~tableName",
                           joinColumns={@JoinColumn(name="~thisid")},
                           inverseJoinColumns={@JoinColumn(name="~otherid")} ) ]|
      , anno|[ @org.hibernate.annotations.IndexColumn(name = "~indexname", base=0) ]|
      , anno|[ @org.hibernate.annotations.Persister(impl = utils.BasicCollectionPersister.class) ]|
      | subselect*
      ]
    where t := <defined-java-type> s
        ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld) <+ ?InverseAnno(ent, fld))> annos
        ; GenericSort("Set", [SimpleSort(yy)]) := <get-type-anno> inv
        ; tableName := <concat-strings> [x_class, "_", x_prop, "_", ss]
        ; thisid    := <concat-strings> ["\\\"", x_class, "_id_owner\\\""]
        ; otherid   := <concat-strings> ["\\\"", ent, "_id_inverse\\\""]
        ; indexname := <concat-strings> ["\\\"", x_class, x_prop,"index\\\""]
        ; subselect* := <get-subselect-anno>

   // bidirectional many-to-many inverse side
   association-annotations(|x_class, x_prop, annos) :
     GenericSort("Set", [s@SimpleSort(ss)]) ->
       [
         anno|[ @ManyToMany( mappedBy="~mappedby", targetEntity=x_ent ,fetch=javax.persistence.FetchType.LAZY) ]|
         , anno|[ @org.hibernate.annotations.Persister(impl = utils.BasicCollectionPersister.class) ]|
         | subselect*
       ]
     where t := <defined-java-type> s
         ; inv := <fetch-elem(?InverseSlaveAnno(ent, fld) <+ ?InverseAnno(ent, fld))> annos
         ; GenericSort("List", [SimpleSort(yy)]) := <get-type-anno> inv
         ; x_ent                            := <concat-strings> [ent, ".class"]
         ; mappedby                         := <concat-strings> ["_", fld]
         ; subselect* := <get-subselect-anno>

rules // cascading annotations

  cascade-annotations :
    Ref() -> [anno|[
      @org.hibernate.annotations.Cascade({
      org.hibernate.annotations.CascadeType.PERSIST,
        org.hibernate.annotations.CascadeType.SAVE_UPDATE,
        org.hibernate.annotations.CascadeType.MERGE
      })
    ]|]

  cascade-annotations :
    Comp() -> [anno|[
      @org.hibernate.annotations.Cascade({
      org.hibernate.annotations.CascadeType.ALL,
      org.hibernate.annotations.CascadeType.DELETE_ORPHAN
      })
    ]|]

  cascade-annotations :
    Simple() -> []

rules // special methods

  property-to-special-getters(|x_Class) :
    prop@Property(x, k, s@GenericSort(coll, [y_srt@SimpleSort(y)]), annos) ->
    class-body-dec* |[
      public t get#x#List() {
        return new ArrayList(get#x());
      }

      public void set#x#List(t x_listvar) {
        //~*bas*
        setChanged();
        set#x(e_newgen);
      }

      public int get#x#Length() {
        return get#x().size();
      }

      ~*cbds
      ~*cbdslist
    ]|
    where <?"Set" <+ ?"List"> coll
    with  t         := <java-type> GenericSort("List", [y_srt])
        ; x_listvar := <newname> "list"
        ; e_newgen  := <owned-collection-transform-list-to-genericset(|x_Class,prop,x_listvar) <+ transform-list-to-genericset(|x_listvar)> s
        //; bas*        := <bidirectional-manytomany-setter(|x_listvar) <+ ![]> prop
        ; cbds      := <collection-mutation-methods(|x_Class) <+ ![]> prop
        ; cbdslist  := <list-mutation-methods(|x_Class) <+ ![]> prop

  property-to-special-getters(|x_Class) :
    DerivedProperty(x_prop, k, s@GenericSort(coll, [y_srt@SimpleSort(y)]), annos, expr) ->
    class-body-dec* |[
      public t x_getList() {
        return new ArrayList(x_get());
      }

      public int x_getLength() {
        return x_get().size();
      }
    ]|
    where <?"Set" <+ ?"List"> coll
    with  t         := <java-type> GenericSort("List", [y_srt])
        ; x_Prop    := <capitalize-string> x_prop
        ; x_getList := <concat-strings>["get", x_Prop, "List"]
        ; x_getLength := <concat-strings>["get", x_Prop, "Length"]
        ; x_get     := <concat-strings>["get", x_Prop]


  transform-list-to-genericset(|x_listvar) :
    GenericSort("List", [s]) -> |[ new java.util.ArrayList<t>(x_listvar) ]|
    with  t := <java-type> s

  transform-list-to-genericset(|x_listvar) :
    GenericSort("Set", [s]) -> |[ new java.util.LinkedHashSet<t>(x_listvar) ]|
    with  t := <java-type> s

  transform-list-to-genericset(|x_listvar) :
    GenericSort("Map", [s1,s2]) -> |[ new java.util.HashMap<t1,t2>(x_listvar) ]|
    with  t1 := <java-type> s1
        ; t2 := <java-type> s2

rules //associations

  prop-has-inverse-anno =
    ?Property(_, _, _, annos)
  ; where(<fetch(?InverseSlaveAnno(_, _) + ?InverseAnno(_, _))> annos)

  inverse-mutation-in-setter(|x) :
    prop@Property(x_prop, k, y_srt@SimpleSort(y), annos) ->
    bstm* |[
        t_y item = newitem;
        t_y oldthing = get#x_prop();
        if(oldthing != newitem)
        {
          if(oldthing!= null && item == null){
            item = oldthing;
            bstm0*
          }
          else if(oldthing != null && item != null){
            bstm1*
            item = oldthing;
            bstm0*
          }
          else if(oldthing == null && item != null ){
            bstm1*
          }
          //manually increase versions in case of one-to-one, to work around hibernate bug, see http://yellowgrass.org/issue/WebDSL/191
          this.increaseVersion();
          if(item != null){ item.increaseVersion(); }
          if(oldthing != null){ oldthing.increaseVersion(); }
    }
    ]|
    where prop-has-inverse-anno
    with  t_y       := <java-type> y_srt
        ; bstm0* := <association-update-statements(remove-bidirectional-reference)> annos
        ; bstm1* := <association-update-statements(add-bidirectional-reference)> annos

  collection-mutation-methods(|x_Class) :
    prop@Property(x_prop, k, s@GenericSort(coll, [y_srt@SimpleSort(y)]), annos) ->
    class-body-dec* |[
      public void removeFrom#x_prop(t_y item) {
        get#x_prop().remove(item);
      }

      public void replaceAllIn#x_prop(java.util.Collection<t_y> col){
        removeAllFrom#x_prop();
        addAllTo#x_prop(col);
      }

      public void removeAllFrom#x_prop() {
        setChanged();
        //force retrieval
        org.hibernate.Hibernate.initialize(get#x_prop());
        while(!get#x_prop().isEmpty()) {
          removeFrom#x_prop(get#x_prop().iterator().next());
        }
      }

      public void addTo#x_prop(t_y item) {
        get#x_prop().add(item);
      }

      public t_col addAllTo#x_prop(java.util.Collection<t_y> col) {
        setChanged();
        Iterator<t_y> it = col.iterator();
        while(it.hasNext()) {
          addTo#x_prop(it.next());
        }
        return get#x_prop(); //needed for desugaring of List.set() and Set.list()
      }
    ]|
    with  t_y       := <java-type> y_srt
        ; x_y       := <java-type-name> y_srt
        ; t_col       := <java-type> s

  list-mutation-methods(|x_Class) :
    prop@Property(x_prop, k, s@GenericSort("List", [srt_y@SimpleSort(y)]), annos) ->
    class-body-dec* |[
      public void setIn#x_prop(int index, t_y newitem) {
        get#x_prop().set(index,newitem);
      }

      public void insertIn#x_prop(int index, t_y item) {
        get#x_prop().add(index, item);
      }

      public void removeAt#x_prop(int index) {
        get#x_prop().remove(index);
      }
    ]|
    with  t_y       := <java-type> srt_y

  get-inverse-anno:
    annos -> (inv, type)
    with   inv := <fetch-elem(?InverseSlaveAnno(x_c, x_p) + ?InverseAnno(x_c, x_p))> annos
         ; type := <get-type-anno> inv

  get-inverse-type = get-inverse-anno; ?(_, <id>)

  if-inverse-is-set(|annos) = inverse-is-set(|annos) <+ ![]
  inverse-is-set(|annos) :
    bstm* -> bstm*
    where GenericSort("Set",[_]) := <get-inverse-type> annos

  if-inverse-is-list(|annos) = inverse-is-list(|annos) <+ ![]
  inverse-is-list(|annos) :
    bstm* -> bstm*
    where GenericSort("List",[_]) := <get-inverse-type> annos

  if-inverse-is-simple(|annos) = inverse-is-simple(|annos) <+ ![]
  inverse-is-simple(|annos) :
    bstm* -> bstm*
    where SimpleSort(_) := <get-inverse-type> annos

  association-update-statements(s) :
    annos -> bstm0*
    where inverse := <filter(?InverseSlaveAnno(_, _) + ?InverseAnno(_, _))> annos
        ; if [] := inverse then
            bstm0* := []
          else
            bstm0* := <filter(s);concat-with-sublists> inverse
          end

  remove-bidirectional-reference :
    inv@name#([x_c, x_p]) ->
      bstm* |[
        //if ( item.x_getInverse().contains(this) ) { //check not necessary
          item.removeFrom#x_p(this);
        //}
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; GenericSort(coll,[_]) := <get-type-anno> inv
        ; <?"Set" <+ ?"List"> coll
    with  x_P := <capitalize-string> x_p
        ; x_getInverse := <concat-strings>["get", x_P]

  remove-bidirectional-reference(|x_target) :
    inv@name#([x_c, x_p]) ->
      bstm* |[
        item.removeFrom#x_p(x_target);
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; GenericSort(coll,[_]) := <get-type-anno> inv
        ; <?"Set" <+ ?"List"> coll
    with  x_P := <capitalize-string> x_p
        ; x_getInverse := <concat-strings>["get", x_P]

  remove-bidirectional-reference(|x_target) :
    inv@name#([x_c, x_p]) -> bstm* |[ item.set#x_p(null); ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; SimpleSort(_) := <get-type-anno> inv

  remove-bidirectional-reference :
    inv@name#([x_c, x_p]) -> bstm* |[ item.set#x_p(null); ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; SimpleSort(_) := <get-type-anno> inv

  add-bidirectional-reference :
    inv@name#([x_c, x_p]) ->
      bstm* |[
        //if ( !item.get#x_p().contains(this) ) { //check disabled because it would cause incorrect behavior for lists which can contain duplicates
          item.addTo#x_p(this);
        //}
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; GenericSort(coll,[_]) := <get-type-anno> inv
        ; <?"Set" <+ ?"List"> coll

  add-bidirectional-reference(|x_target) :
    inv@name#([x_c, x_p]) ->
      bstm* |[
        //if ( !item.get#x_p().contains(this) ) { //check disabled because it would cause incorrect behavior for lists which can contain duplicates
          item.addTo#x_p(x_target);
        //}
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; GenericSort(coll,[_]) := <get-type-anno> inv
        ; <?"Set" <+ ?"List"> coll

  add-bidirectional-reference :
    inv@name#([x_c, x_p]) ->
      bstm* |[
        //if (value.get#x_p() != this) {
        item.set#x_p(this);
        //}
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; SimpleSort(_) := <get-type-anno> inv

  add-bidirectional-reference(|x_target) :
    inv@name#([x_c, x_p]) ->
      bstm* |[
        //if (value.get#x_p() != this) {
        item.set#x_p(x_target);
        //}
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; SimpleSort(_) := <get-type-anno> inv
